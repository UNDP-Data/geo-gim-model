

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Interfaces &mdash; AI Framework 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Preprocessing" href="preprocessing.html" />
    <link rel="prev" title="Datasets" href="datasets.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> AI Framework
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Segmentation models:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="datasets.html">Datasets</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#reading-files">Reading files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-files">Writing files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#developer-notes">Developer Notes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#migrating-interfaces-to-rioxarray-and-geocube">Migrating interfaces to rioxarray and geocube</a></li>
<li class="toctree-l3"><a class="reference internal" href="#out-of-core-shapefile-rasterisation">Out-of-core shapefile rasterisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-class-segmentation">Multi-class segmentation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="preprocessing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="training.html">Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="polygonisation.html">Polygonisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="corrections.html">Correcting unsatisfcatory segmentation results</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">AI Framework</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/interfaces.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="interfaces">
<h1>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h1>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">gim_cv.interfaces</span></code> submodule is a relatively low-level submodule
responsible for providing interfaces which perform:</p>
<ul class="simple">
<li><p>The extraction of <a class="reference external" href="https://docs.dask.org/en/latest/array.html">Dask arrays</a> (containing the raw numerical grid data)
from raster and shape files.</p></li>
<li><p>The writing of output arrays (containing e.g. inference results) back to raster
files.</p></li>
</ul>
<p>This is a necessary intermediate step linking the source data files to preprocessing
pipelines for training and inference, and for writing mask arrays during inference
back to raster files.</p>
<p>Currently supported is the extraction/writing of image and mask arrays from/to
multi-channel rasters, and reading single-channel masks from shapefiles.</p>
<p>For an end-user it is <em>not necessary to understand the details</em> of this, as this
logic is dealt with by the <code class="xref py py-class docutils literal notranslate"><span class="pre">TrainingDataset</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">InferenceDataset</span></code> classes, so you can skip to
<a class="reference internal" href="preprocessing.html"><span class="doc">Preprocessing</span></a>. Note however that it is <strong>highly recommended</strong>
to use <code class="docutils literal notranslate"><span class="pre">.tif</span></code> format for rasters (these are much faster to read/write to which
speeds up training and inference massively with respect to <code class="docutils literal notranslate"><span class="pre">.jp2</span></code>). It is
currently also <strong>necessary</strong> to use <code class="docutils literal notranslate"><span class="pre">.shp</span></code> format for vector mask data.</p>
<div class="section" id="reading-files">
<h2>Reading files<a class="headerlink" href="#reading-files" title="Permalink to this headline">¶</a></h2>
<p>The necessary interface class for a given file extension can be obtained with the
function <code class="xref py py-func docutils literal notranslate"><span class="pre">get_interface()</span></code>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the appropriate classes for reading from tif and shapefiles</span>
<span class="n">tif_reader</span> <span class="o">=</span> <span class="n">get_interface</span><span class="p">(</span><span class="s1">&#39;raster.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;ImageReader&#39;</span><span class="p">)</span>
<span class="n">shp_reader</span> <span class="o">=</span> <span class="n">get_interface</span><span class="p">(</span><span class="s1">&#39;vector_mask.shp&#39;</span><span class="p">,</span> <span class="s1">&#39;BinaryMaskReader&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A reader object can be constructed with the appropriate class by instantiating it
with the file path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># instantiate a reader object for each of these specific files</span>
<span class="n">raster_reader</span> <span class="o">=</span> <span class="n">tif_reader</span><span class="p">(</span><span class="s1">&#39;raster.tif&#39;</span><span class="p">,</span> <span class="n">read_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">vector_mask_reader</span> <span class="o">=</span> <span class="n">shp_reader</span><span class="p">(</span><span class="s1">&#39;vector_mask.shp&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">raster_reader</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">read_metadata</span></code> argument will populate the <code class="docutils literal notranslate"><span class="pre">metadata</span></code> attribute of the reader
object with the co-ordinate reference system and geo-transform of the raster (as
implemented in <a class="reference external" href="https://rasterio.readthedocs.io/en/latest/">rasterio</a>). This can then be passed to the vector reader to tell it
which co-ordinate system and spatial resolution to use when rasterising the shapefile.
If the mask is itself already a georeferenced <code class="docutils literal notranslate"><span class="pre">.tif</span></code> raster, this is obviously not
necessary and the geospatial metadata can be read directly.</p>
<p>The dask arrays containing the raw image (or mask) data can then be constructed with the
method <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_array()</span></code>, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">raster_reader</span><span class="o">.</span><span class="n">load_array</span><span class="p">()</span>
<span class="n">vector_mask_reader</span><span class="o">.</span><span class="n">load_array</span><span class="p">()</span>
</pre></div>
</div>
<p>This will assign the corresponding dask arrays to the <code class="docutils literal notranslate"><span class="pre">array</span></code> attributes, at which point
preprocessing can be performed.</p>
<div class="section" id="limitations">
<h3>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h3>
<p>One current limitation of the shapefile interface is that the rasterised array created from
the shapefile must fit in RAM. This means that if you have a very large training dataset,
consisting of a (set of) large RGB raster(s), there is a possibility of blowing up memory.</p>
<p>This can be circumvented by first <a class="reference external" href="https://gdal.org/programs/gdal_rasterize.html">rasterising the shapefile with GDAL</a> and using an explicit <code class="docutils literal notranslate"><span class="pre">.tif</span></code>  mask raster.
This is because raster reading is implemented with dask (and thus out-of-core chunkwise
computations are the norm) while shape reading is implemented with the GDAL python bindings.</p>
<p>A permanent solution to this would be to implement out-of-core shapefile reading with Dask.
See <a class="reference internal" href="#inference-dev-notes"><span class="std std-ref">Developer Notes</span></a>.</p>
</div>
</div>
<div class="section" id="writing-files">
<h2>Writing files<a class="headerlink" href="#writing-files" title="Permalink to this headline">¶</a></h2>
<p>The same interface classes can be used to write an array (a segmentation mask
generated by a model) to a raster file. Directly writing to shape is not supported
yet, but can be done with a small amount of effort (see <a class="reference internal" href="polygonisation.html"><span class="doc">Polygonisation</span></a>).
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the appropriate interface class for writing a binary tif mask</span>
<span class="n">tif_writer</span> <span class="o">=</span> <span class="n">get_interface</span><span class="p">(</span><span class="s1">&#39;output_mask.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;BinaryMaskWriter&#39;</span><span class="p">)</span>
<span class="c1"># instantiate mask writer - this inherits the geospatial metadata from the</span>
<span class="c1"># image consumed by the model to create it</span>
<span class="n">mask_writer</span> <span class="o">=</span> <span class="n">tif_writer</span><span class="p">(</span><span class="s1">&#39;output_mask.tif&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">raster_reader</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
<span class="c1"># assign the array to be written out (a dask array, generated by a model)</span>
<span class="n">mask_writer</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">inferred_mask</span>
<span class="c1"># write out the mask to the tif file</span>
<span class="n">mask_writer</span><span class="o">.</span><span class="n">write_raster</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="developer-notes">
<span id="inference-dev-notes"></span><h2>Developer Notes<a class="headerlink" href="#developer-notes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="migrating-interfaces-to-rioxarray-and-geocube">
<h3>Migrating interfaces to rioxarray and geocube<a class="headerlink" href="#migrating-interfaces-to-rioxarray-and-geocube" title="Permalink to this headline">¶</a></h3>
<p>Some time during the writing of this library the tools <a class="reference external" href="https://corteva.github.io/rioxarray/stable/">rioxarray</a> and <a class="reference external" href="https://corteva.github.io/geocube/stable/">geocube</a>
rose out of obscurity and became promising interfaces for general geospatial raster and
vector files (among other things).</p>
<p>The former is built on <a class="reference external" href="https://rasterio.readthedocs.io/en/latest/">rasterio</a> (like the main <code class="docutils literal notranslate"><span class="pre">.tif</span></code> and <code class="docutils literal notranslate"><span class="pre">.jp2</span></code>
interfaces native to this library) and <a class="reference external" href="https://xarray.pydata.org/en/stable/">xarray</a>, and has native dask support. This
could quite easily replace the raster file &lt;-&gt; dask array interface code in this
library while being more concise and actively developed by a community. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">rioxarray</span> <span class="k">as</span> <span class="nn">rx</span>

<span class="n">raster_array</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="s1">&#39;raster.tif&#39;</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">5120</span><span class="p">,</span> <span class="mi">5120</span><span class="p">))</span>
</pre></div>
</div>
<p>Builds an xarray object equipped with various geospatial methods (reprojection, crs
transformations, cutting by polygons etc.) tied to an underlying dask array
accessible through the <code class="docutils literal notranslate"><span class="pre">data</span></code> attribute.</p>
<p><a class="reference external" href="https://corteva.github.io/geocube/stable/">geocube</a> provides a convenient API for rasterising vector files through its
<code class="docutils literal notranslate"><span class="pre">make_geocube</span></code> function which builds an xarray object tied to a numpy array
from a vector file which can be in various formats (shapefile, geopackage,
geojson etc.). It does not have native dask support, but I have opened <a class="reference external" href="https://github.com/corteva/geocube/issues/41">a ticket</a>
about this and don’t believe it would be too difficult to implement for someone who
understands dask reasonably well.</p>
<p>Used together these might replace the interfaces submodule with a more convenient
API in future.</p>
<p>You can see some examples of how these libraries can be used in the notebooks
directory of the source code.</p>
</div>
<div class="section" id="out-of-core-shapefile-rasterisation">
<h3>Out-of-core shapefile rasterisation<a class="headerlink" href="#out-of-core-shapefile-rasterisation" title="Permalink to this headline">¶</a></h3>
<p>For out-of-core (larger than memory) shapefile rasterisation, an easier short-term
alternative to the strategy outlined above (using geocube and implementing dask
support) may be to reimplement <code class="xref py py-func docutils literal notranslate"><span class="pre">gim_cv.interfaces.shp.ogr.rasterise_shapefile()</span></code>
to use a <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> wrapper around GDAL with smaller spatial chunks to define a lazy
raster.</p>
</div>
<div class="section" id="multi-class-segmentation">
<h3>Multi-class segmentation<a class="headerlink" href="#multi-class-segmentation" title="Permalink to this headline">¶</a></h3>
<p>The interfaces module is where the lion’s share of the necessary work is for fully implementing
multi-class segmentation.</p>
<p>Multi-class segmentation should already be largely possible if one sticks to datasets with
<code class="docutils literal notranslate"><span class="pre">.tif</span></code> format pre-rasterised masks, and defines preprocessing pipelines to correctly
separate the different classes over the channel dimension.</p>
<p>To implement it for datasets with shapefile masks one need to add logic for distinguishing different
polygon features by the relevant properties that determine their class. As it stands this would
require extending the <code class="xref py py-mod docutils literal notranslate"><span class="pre">gim_cv.interfaces.shp</span></code> submodule, in particular adding logic to
<code class="xref py py-func docutils literal notranslate"><span class="pre">gim_cv.interfaces.shp.ogr.rasterise_shapefile()</span></code> such that different features are written to
different bands.</p>
<p>This should also be possible and reasonably simple if masks are rasterised using geocube.</p>
<p>My recommendation would be to add a <code class="docutils literal notranslate"><span class="pre">geocube</span></code> submodule to <code class="xref py py-mod docutils literal notranslate"><span class="pre">gim_cv.interfaces.shp</span></code>, implement
dask support and separation of different features into raster bands in one go.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="preprocessing.html" class="btn btn-neutral float-right" title="Preprocessing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="datasets.html" class="btn btn-neutral float-left" title="Datasets" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Nlemba Laurent, Liam Moore.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>