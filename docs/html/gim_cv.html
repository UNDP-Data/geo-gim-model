

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>gim_cv package &mdash; AI Framework 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="gim_cv.interfaces package" href="gim_cv.interfaces.html" />
    <link rel="prev" title="Miscellaneous" href="misc.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> AI Framework
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Segmentation models:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="preprocessing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="training.html">Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="polygonisation.html">Polygonisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
</ul>
<p class="caption"><span class="caption-text">Main package:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">gim_cv package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gim_cv.interfaces.html">gim_cv.interfaces package</a></li>
<li class="toctree-l3"><a class="reference internal" href="gim_cv.scrapers.html">gim_cv.scrapers package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.callbacks">gim_cv.callbacks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.config">gim_cv.config module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.dask_tools">gim_cv.dask_tools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.datasets">gim_cv.datasets module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#to-do">To do</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.exceptions">gim_cv.exceptions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.inference">gim_cv.inference module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.losses">gim_cv.losses module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.metrics">gim_cv.metrics module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.orchestration">gim_cv.orchestration module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.preprocessing">gim_cv.preprocessing module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.training">gim_cv.training module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.tuners">gim_cv.tuners module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv.utils">gim_cv.utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-gim_cv">Module contents</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">AI Framework</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>gim_cv package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/gim_cv.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="gim-cv-package">
<h1>gim_cv package<a class="headerlink" href="#gim-cv-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="gim_cv.interfaces.html">gim_cv.interfaces package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="gim_cv.interfaces.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gim_cv.interfaces.jp2.html">gim_cv.interfaces.jp2 package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.jp2.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.jp2.html#module-gim_cv.interfaces.jp2.gdal">gim_cv.interfaces.jp2.gdal module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.jp2.html#module-gim_cv.interfaces.jp2.rasterio">gim_cv.interfaces.jp2.rasterio module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.jp2.html#module-gim_cv.interfaces.jp2">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gim_cv.interfaces.shp.html">gim_cv.interfaces.shp package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.shp.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.shp.html#module-gim_cv.interfaces.shp.fiona">gim_cv.interfaces.shp.fiona module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.shp.html#module-gim_cv.interfaces.shp.ogr">gim_cv.interfaces.shp.ogr module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.shp.html#module-gim_cv.interfaces.shp">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gim_cv.interfaces.tif.html">gim_cv.interfaces.tif package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.tif.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.tif.html#module-gim_cv.interfaces.tif.rasterio">gim_cv.interfaces.tif.rasterio module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.interfaces.tif.html#module-gim_cv.interfaces.tif">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gim_cv.interfaces.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="gim_cv.interfaces.html#module-gim_cv.interfaces.base">gim_cv.interfaces.base module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gim_cv.interfaces.html#module-gim_cv.interfaces">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="gim_cv.scrapers.html">gim_cv.scrapers package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="gim_cv.scrapers.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html">gim_cv.scrapers.vl_orthos package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html#module-gim_cv.scrapers.vl_orthos.items">gim_cv.scrapers.vl_orthos.items module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html#module-gim_cv.scrapers.vl_orthos.middlewares">gim_cv.scrapers.vl_orthos.middlewares module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html#module-gim_cv.scrapers.vl_orthos.pipelines">gim_cv.scrapers.vl_orthos.pipelines module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html#module-gim_cv.scrapers.vl_orthos.settings">gim_cv.scrapers.vl_orthos.settings module</a></li>
<li class="toctree-l4"><a class="reference internal" href="gim_cv.scrapers.vl_orthos.html#module-gim_cv.scrapers.vl_orthos">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gim_cv.scrapers.html#module-gim_cv.scrapers">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-gim_cv.callbacks">
<span id="gim-cv-callbacks-module"></span><h2>gim_cv.callbacks module<a class="headerlink" href="#module-gim_cv.callbacks" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="gim_cv.callbacks.NBatchLogger">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.callbacks.</code><code class="sig-name descname">NBatchLogger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">display</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.callbacks.NBatchLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.keras.callbacks.Callback</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>A Logger that log average performance per <cite>display</cite> steps.</p>
<p>initial credit:
<a class="reference external" href="https://github.com/keras-team/keras/issues/2850#issuecomment-371353851">https://github.com/keras-team/keras/issues/2850#issuecomment-371353851</a></p>
<dl class="py method">
<dt id="gim_cv.callbacks.NBatchLogger.on_batch_end">
<code class="sig-name descname">on_batch_end</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">batch</span></em>, <em class="sig-param"><span class="n">logs</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.callbacks.NBatchLogger.on_batch_end" title="Permalink to this definition">¶</a></dt>
<dd><p>A backwards compatibility alias for <cite>on_train_batch_end</cite>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gim_cv.config">
<span id="gim-cv-config-module"></span><h2>gim_cv.config module<a class="headerlink" href="#module-gim_cv.config" title="Permalink to this headline">¶</a></h2>
<p>config.py</p>
<p>Loads a configuration yaml file ‘config.yml’ in this directory, executes
logic on its content and makes its contents available to other modules
by importing this module as e.g.:</p>
<blockquote>
<div><p>&gt;&gt; import gim_cv.config as cfg
&gt;&gt; print(cfg.data_path)</p>
</div></blockquote>
<p><cite>config.yml</cite> contains various paths which allow one to define which directories
are used for storing data, models and results.</p>
<dl class="py function">
<dt id="gim_cv.config.get_config_path">
<code class="sig-prename descclassname">gim_cv.config.</code><code class="sig-name descname">get_config_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">configpath_lmo</span><span class="o">=</span><span class="default_value">'/home/root/config.yml'</span></em>, <em class="sig-param"><span class="n">configpath_nma</span><span class="o">=</span><span class="default_value">'C:\\GIT\\buildingage\\config\\config.yml'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.config.get_config_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.config.join">
<code class="sig-prename descclassname">gim_cv.config.</code><code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loader</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.config.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to handle joining paths in yaml file.</p>
<p>When encountering ‘!join’ tags, will treat subsequent items as
a list of strings to be concatenated.</p>
<p>Allows self-referencing paths like !join [*BASE_PATH, /subdirectory/]</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.config.verify_path_exists">
<code class="sig-prename descclassname">gim_cv.config.</code><code class="sig-name descname">verify_path_exists</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">raise_exc</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.config.verify_path_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Check a path exists and raise a FileNotFoundError if not</p>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.dask_tools">
<span id="gim-cv-dask-tools-module"></span><h2>gim_cv.dask_tools module<a class="headerlink" href="#module-gim_cv.dask_tools" title="Permalink to this headline">¶</a></h2>
<p>dask_tools.py</p>
<p>Functions that are used to support preprocessing or data transformation
operations, usually some kind of dask array acrobatics.</p>
<dl class="py function">
<dt id="gim_cv.dask_tools.chunk_generator">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">chunk_generator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.chunk_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function for yielding blocks from a dask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array</p>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> – Numpy arrays corresponding to each block of the dask array in order of
the block indices</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.combine_incomplete_blocks">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">combine_incomplete_blocks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.combine_incomplete_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges incomplete blocks of a dask array into complete blocks</p>
<p>Incomplete blocks are assumed to be those smaller than the max size present,
and blocks are assumed to be divided only along axis 0 (e.g. training
examples).</p>
<p>New blocks formed by combining incomplete blocks are stuck on the end of the
output array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with at least two dimensions and multiple blocks along the
first dimension</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The input dask array, rechunked and reassembled with as many blocks with
the max original size present as possible.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.fold_interleave">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">fold_interleave</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">repeats</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.fold_interleave" title="Permalink to this definition">¶</a></dt>
<dd><p>Performes iterative pseudo-shuffling operation on a dask array.</p>
<p>Chunks are assumed to be along axis 0 only (the samples dimension).</p>
<p>This function folds a dask array on itself along axis 0, then
interleaves the vertically adjacent elements (like shuffling a deck of cards
by splitting it in two, placing one next to the other then interleaving both
halves), repeating <cite>repeats</cite> times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with at least two dimensions and multiple blocks along the
first dimension</p></li>
<li><p><strong>repeats</strong> (<em>int</em>) – The number of times to perform the folding shuffle operation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The pseudo-shuffled input array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.fold_interleave_together">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">fold_interleave_together</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">shuffle_blocks</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">repeats</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.fold_interleave_together" title="Permalink to this definition">¶</a></dt>
<dd><p>Performes synchronised pseudo-shuffling operation on a pair of dask arrays.</p>
<p>Chunks are assumed to be along axis 0 only (the samples dimension). All
chunks are assumed to be the same size!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with at least two dimensions and multiple blocks along the
first dimension. Typically training inputs/images.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with at least two dimensions and multiple blocks along the
first dimension. Typically training labels/masks.</p></li>
<li><p><strong>shuffle_blocks</strong> (<em>bool</em>) – Flag controlling whether block orders are additionally shuffled each
iteration.</p></li>
<li><p><strong>repeats</strong> (<em>int</em>) – The number of times to perform the folding shuffle operation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code> – The pseudo-shuffled first input array</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code> – The pseudo-shuffled second input array</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.get_full_blocks">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">get_full_blocks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.get_full_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subset of the input dask array made of full blocks.</p>
<p>Full blocks are assumed to be those of the max size present, and blocks
are assumed to be aligned along axis 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with chunking along axis 0 only (typically the samples
dimension)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A subset of the input array where the blocks are all those with the
max chunk size present in the original array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.get_incomplete_blocks">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">get_incomplete_blocks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.get_incomplete_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subset of the input dask array made of incomplete blocks.</p>
<p>Incomplete blocks are assumed to be those smaller than the max size present,
and blocks are assumed to be aligned along axis 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with chunking along axis 0 only (typically the samples
dimension)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A subset of the input array where the blocks are all those with size
smaller than the max chunk size present in the original array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.pair_chunk_generator">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">pair_chunk_generator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">shuffle_blocks</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.pair_chunk_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function to yield corresponding blocks of a pair of dask arrays</p>
<p>Useful for machine learning model training data generators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with the same number of blocks as X whose elements
correspond</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.ndarray</span></code> – A pair of numpy arrays corresponding to the blocks of the inputs X and y</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.shuffle_blocks">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">shuffle_blocks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.shuffle_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffles the order of the blocks present in a dask array</p>
<p>Chunks are assumed to be along axis 0 only (the samples dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with chunking along axis 0 only (typically the samples
dimension)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The input array with blocks reordered by a random permutation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.shuffle_blocks_together">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">shuffle_blocks_together</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.shuffle_blocks_together" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffles the blocks of a pair of dask arrays by the same random permutation</p>
<p>Used for synchronised shuffling operations on training inputs and labels.</p>
<p>Blocks are assumed to be aligned along axis 0 only, as is typical for
arrays containing training examples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with chunking along axis 0</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with chunking along axis 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – The first input dask array with its blocks shuffled</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – The second input dask array with its blocks shuffled</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.shuffuhl_together">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">shuffuhl_together</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">shuffle_blocks</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">repeats</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.shuffuhl_together" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffles two dask arrays so corresponding elements end up in the same place</p>
<p>Designed to shuffle pairs of image/mask arrays to achieve a degree of
data dispersal without invoking a full random shuffle and blowing up memory.
Combines shuffling of blocks within the array with a repeated
‘fold interleave’ operation. Accounts for complete and incomplete blocks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with chunks along axis = 0. Typically training examples.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with chunks along axis = 0. Typically corresponding masks.</p></li>
<li><p><strong>shuffle_blocks</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flags whether to shuffle the blocks during the fold interleave operation
(if not, will just do once at the end).</p></li>
<li><p><strong>repeats</strong> (<em>int</em><em>, </em><em>optional</em>) – Specifies how many times to perform the <cite>fold_interleave_together</cite>
operation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code> – Pseudo-shuffled version of first input array</p></li>
<li><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code> – Pseudo-shuffled version of second input array</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.dask_tools.stack_interleave_flatten">
<code class="sig-prename descclassname">gim_cv.dask_tools.</code><code class="sig-name descname">stack_interleave_flatten</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.dask_tools.stack_interleave_flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Performes folding and interleaving operation on a dask array.</p>
<p>Chunks are assumed to be along axis 0 only (the samples dimension).</p>
<p>This function folds a dask array on itself along axis 0, then
interleaves the vertically adjacent elements (like shuffling a deck of cards
by splitting it in two, placing one next to the other then interleaving both
halves).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array with at least two dimensions and multiple blocks along the
first dimension</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The input array, with its elements now alternating between those of the
first and second halves of the array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.datasets">
<span id="gim-cv-datasets-module"></span><h2>gim_cv.datasets module<a class="headerlink" href="#module-gim_cv.datasets" title="Permalink to this headline">¶</a></h2>
<p>datasets.py</p>
<p>Provides functionality for constructing ML-ready datasets from raw files</p>
<p>Defines collections of input data for training or inference, locally (by
setting file paths directly) or remotely (by specifying methods to download
files given their URLs)</p>
<p>Some pre-defined remote datasets are defined here - for example, the Flemish
orthophotos.</p>
<div class="section" id="to-do">
<h3>To do<a class="headerlink" href="#to-do" title="Permalink to this headline">¶</a></h3>
<p>The APIs for datasets and dataloaders and dataloader factories and suchlike
are a bit clunky atm but I haven’t had time to revisit them and structure
them more intuitively. Feel free to open a pull request!</p>
<p>As more datasets are added this file will get quite monolithic. Perhaps
split individual datasets into submodules. For this may need to slightly
redesign the tag descriptor or introspect the module namespace for Datasets.</p>
<dl class="py class">
<dt id="gim_cv.datasets.Dataset">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">Dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tag</span></em>, <em class="sig-param"><span class="n">spatial_resolution</span></em>, <em class="sig-param"><span class="n">image_paths</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">mask_paths</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">image_download_fn</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask_download_fn</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">all_download_fn</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">register_tag</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Class which groups together raster and/or shapefiles into a dataset</p>
<p>Datasets are identifiable via their tag attribute, and must have an
assigned spatial resolution (to give an understanding of compatibility
and where one needs to rescale when using more than one together)</p>
<p>Datasets can be combined with the addition operator, merging their
files into a single list if their spatial resolutions are ~the same</p>
<p>Can be provided an optional image_download_fn, mask_download_fn, and/or
all_download_fn to retrieve the files from the internet. This should be
asynchronous to enable it to work in the background.</p>
<p>all_download_fn incase it’s only possible to download both sets at once
(say, a zip archive)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tag</strong> (<em>str</em>) – A string identifier for this dataset</p></li>
<li><p><strong>spatial_resolution</strong> (<em>float</em>) – The spatial resolution of the rasters in this dataset (in a given
Dataset, these should all be the same). Used to guide resampling
operations downstream.</p></li>
<li><p><strong>image_paths</strong> (list of (str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code>), optional) – A list of the constituent raster files.</p></li>
<li><p><strong>mask_paths</strong> (list of (str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code>), optional) – A list of the constituent mask files if appropriate, in one-to-one
correspondence with the images in image_paths. These can also be
shapefiles, which are rasterised and converted into masks by a
preprocessing operation downstream.</p></li>
<li><p><strong>image_download_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – A function which downloads raster files and returns a list of the paths
of the files downloaded</p></li>
<li><p><strong>mask_download_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – A function which downloads mask files and returns a list of the paths of
the files downloaded</p></li>
<li><p><strong>all_download_fn_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – A function which downloads both rasters and masks and returns a 2-tuple
of the lists of paths to each respectively</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.datasets.Dataset.all_files_exist">
<em class="property">property </em><code class="sig-name descname">all_files_exist</code><a class="headerlink" href="#gim_cv.datasets.Dataset.all_files_exist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.delete_image_files">
<code class="sig-name descname">delete_image_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.delete_image_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.delete_mask_files">
<code class="sig-name descname">delete_mask_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">force</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.delete_mask_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.download_all_files">
<em class="property">async </em><code class="sig-name descname">download_all_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img_save_dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask_save_dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">img_kw</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">msk_kw</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">all_kw</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.download_all_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.download_image_files">
<em class="property">async </em><code class="sig-name descname">download_image_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">save_dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">fn_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.download_image_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.download_mask_files">
<em class="property">async </em><code class="sig-name descname">download_mask_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">save_dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">fn_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.download_mask_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.file_download_available">
<em class="property">property </em><code class="sig-name descname">file_download_available</code><a class="headerlink" href="#gim_cv.datasets.Dataset.file_download_available" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.image_files_exist">
<em class="property">property </em><code class="sig-name descname">image_files_exist</code><a class="headerlink" href="#gim_cv.datasets.Dataset.image_files_exist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.load_inference_data">
<code class="sig-name descname">load_inference_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image_pipeline_factory</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">image_validation_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">pipeline_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.load_inference_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates multi-file inference datasets with chosen preprocessing pipelines</p>
<p>Returns a (Composite)InferenceDataset from the parent dataset’s rasters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_pipeline_factory</strong> (<em>optional</em>) – A function which returns a preprocessing pipeline for each image array. Uses
default inference pipeline for this dataset if None.</p></li>
<li><p><strong>image_validation_function</strong> (<em>optional</em>) – A function which accepts an image array and returns True if valid and False
otherwise. Defers to defaults defined per dataset (see the
IMAGE_VALIDATION_FUNCTIONS dict which defaults to None).</p></li>
<li><p><strong>pipeline_kwargs</strong> (<em>optional</em>) – Any parameters which can be passed to the pipeline factory function, for
example inference_window_size</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#gim_cv.inference.CompositeInferenceDataset" title="gim_cv.inference.CompositeInferenceDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gim_cv.inference.CompositeInferenceDataset</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.load_training_data">
<code class="sig-name descname">load_training_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image_pipeline_factory</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask_pipeline_factory</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">image_validation_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask_validation_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">batch_generator_fn</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_val_test_split</span><span class="o">=</span><span class="default_value">(0.9, 0.1)</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">pipeline_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.load_training_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates multi-file training datasets with chosen preprocessing pipelines</p>
<p>Returns a (Composite)TrainingDataset from a the image/mask files of the
parent Dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_size</strong> – batch size</p></li>
<li><p><strong>train_val_test_split</strong> – A two- or three-element tuple with fractions of data used for training,
validation and testing. If two elements, no testing set will be used.</p></li>
<li><p><strong>batch_generator_fn</strong> – A batch generator function</p></li>
<li><p><strong>image_pipeline_factory</strong> – A function which returns a preprocessing pipeline for each image array</p></li>
<li><p><strong>mask_pipeline_factory</strong> – A function which returns a preprocessing pipeline for each mask array</p></li>
<li><p><strong>image_validation_function</strong> – todo</p></li>
<li><p><strong>mask_validation_function</strong> – todo</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#gim_cv.training.CompositeTrainingDataset" title="gim_cv.training.CompositeTrainingDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gim_cv.training.CompositeTrainingDataset</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.datasets.Dataset.print_summary">
<code class="sig-name descname">print_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.Dataset.print_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="gim_cv.datasets.Dataset.tag">
<code class="sig-name descname">tag</code><a class="headerlink" href="#gim_cv.datasets.Dataset.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>descriptor</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.get_binary_mask_training_pipeline_by_tag">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">get_binary_mask_training_pipeline_by_tag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tag</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.get_binary_mask_training_pipeline_by_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dataset-appropriate pipeline for preprocessing masks for inference</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag</strong> (<em>str</em>) – The tag of the dataset for which to get the inference pipeline</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pipeline for preprocessing this dataset’s raster data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sklearn.pipeline.Pipeline</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Written in this form to allow overriding default pipelines for some datasets</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.get_dataset">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">get_dataset</code><span class="sig-paren">(</span><em class="sig-param">tag</em>, <em class="sig-param">registry={'Vlaanderen_1979-1990_100cm': Dataset(tag=Vlaanderen_1979-1990_100cm</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2000-2003_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2000-2003_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2000-2003_30cm_missing_tiles_resampled_30pct': Dataset(tag=Vlaanderen_2000-2003_30cm_missing_tiles_resampled_30pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2000-2003_30cm_resampled_30pct': Dataset(tag=Vlaanderen_2000-2003_30cm_resampled_30pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2005-2007_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2005-2007_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2008-2011_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2008-2011_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2012_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2012_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2013_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2013_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2014_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2014_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2015_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2015_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2016_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2016_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2017_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2017_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2018_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2018_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2019_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2019_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_meest recent_25cm_resampled_25pct': Dataset(tag=Vlaanderen_meest recent_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallona_1994-2000_40cm_missing_tiles_resampled_40pct': Dataset(tag=Wallona_1994-2000_40cm_missing_tiles_resampled_40pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_1994-2000_40cm_resampled_40pct': Dataset(tag=Wallonia_1994-2000_40cm_resampled_40pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2006-2007_50cm_resampled_50pct': Dataset(tag=Wallonia_2006-2007_50cm_resampled_50pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2009-2010_25cm_resampled_25pct': Dataset(tag=Wallonia_2009-2010_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2013_25cm_resampled_25pct': Dataset(tag=Wallonia_2013_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2015_25cm_resampled_25pct': Dataset(tag=Wallonia_2015_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2019_25cm_resampled_25pct': Dataset(tag=Wallonia_2019_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'belgium_ortho_2001': Dataset(tag=belgium_ortho_2001</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2007': Dataset(tag=belgium_ortho_2007</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2009': Dataset(tag=belgium_ortho_2009</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015': Dataset(tag=belgium_ortho_2015</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra': Dataset(tag=belgium_ortho_2015_extra</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_0': Dataset(tag=belgium_ortho_2015_extra_0</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_2': Dataset(tag=belgium_ortho_2015_extra_2</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_3': Dataset(tag=belgium_ortho_2015_extra_3</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_4': Dataset(tag=belgium_ortho_2015_extra_4</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2016': Dataset(tag=belgium_ortho_2016</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_no_2001': Dataset(tag=belgium_ortho_no_2001</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_topo_1969': Dataset(tag=belgium_topo_1969</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'col_bar_19_40cm': Dataset(tag=col_bar_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_40cm_full': Dataset(tag=col_bar_19_40cm_full</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_40cm_test': Dataset(tag=col_bar_19_40cm_test</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_40cm_test_full': Dataset(tag=col_bar_19_40cm_test_full</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_6cm': Dataset(tag=col_bar_19_6cm</em>, <em class="sig-param">spatial_resolution=0.06)</em>, <em class="sig-param">'col_med_19_10m': Dataset(tag=col_med_19_10m</em>, <em class="sig-param">spatial_resolution=10.0)</em>, <em class="sig-param">'col_med_19_40cm': Dataset(tag=col_med_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_med_19_40cm_test': Dataset(tag=col_med_19_40cm_test</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'gim': Dataset(tag=gim</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'inria': Dataset(tag=inria</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_austin': Dataset(tag=inria_austin</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_chicago': Dataset(tag=inria_chicago</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_eu': Dataset(tag=inria_eu</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_kitsap': Dataset(tag=inria_kitsap</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_tyrol': Dataset(tag=inria_tyrol</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_vienna': Dataset(tag=inria_vienna</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'lux_18_1m_rgb': Dataset(tag=lux_18_1m_rgb</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'lux_18_aois_rgb': Dataset(tag=lux_18_aois_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_18_rgb': Dataset(tag=lux_18_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_1m_rgb': Dataset(tag=lux_19_1m_rgb</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'lux_19_aois_rgb': Dataset(tag=lux_19_aois_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_repeat': Dataset(tag=lux_19_repeat</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_repeat_20cm': Dataset(tag=lux_19_repeat_20cm</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_rgb': Dataset(tag=lux_19_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_true_aois_rgb': Dataset(tag=lux_19_true_aois_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'massachusetts': Dataset(tag=massachusetts</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'nig_mak_19_10m': Dataset(tag=nig_mak_19_10m</em>, <em class="sig-param">spatial_resolution=10.0)</em>, <em class="sig-param">'nig_mak_19_50cm': Dataset(tag=nig_mak_19_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_1420_50cm': Dataset(tag=phil_man_1420_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_1420_50cm_bis': Dataset(tag=phil_man_1420_50cm_bis</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm': Dataset(tag=phil_man_14_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_01': Dataset(tag=phil_man_14_50cm_01</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_02': Dataset(tag=phil_man_14_50cm_02</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_03': Dataset(tag=phil_man_14_50cm_03</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_04': Dataset(tag=phil_man_14_50cm_04</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_05': Dataset(tag=phil_man_14_50cm_05</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_ne': Dataset(tag=phil_man_19_50cm_ne</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_nw': Dataset(tag=phil_man_19_50cm_nw</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_se': Dataset(tag=phil_man_19_50cm_se</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_sw': Dataset(tag=phil_man_19_50cm_sw</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_test': Dataset(tag=phil_man_19_50cm_test</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm': Dataset(tag=phil_man_20_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_4gp': Dataset(tag=phil_man_20_50cm_4gp</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_6gp': Dataset(tag=phil_man_20_50cm_6gp</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_bis': Dataset(tag=phil_man_20_50cm_bis</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_bis_test': Dataset(tag=phil_man_20_50cm_bis_test</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_full': Dataset(tag=phil_man_20_50cm_full</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_test': Dataset(tag=phil_man_20_50cm_test</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_tris': Dataset(tag=phil_man_20_50cm_tris</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_ax': Dataset(tag=phil_man_20_50cm_xtra_ax</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_ax_val': Dataset(tag=phil_man_20_50cm_xtra_ax_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_az': Dataset(tag=phil_man_20_50cm_xtra_az</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_az_val': Dataset(tag=phil_man_20_50cm_xtra_az_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bx': Dataset(tag=phil_man_20_50cm_xtra_bx</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bx_val': Dataset(tag=phil_man_20_50cm_xtra_bx_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bz': Dataset(tag=phil_man_20_50cm_xtra_bz</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bz_val': Dataset(tag=phil_man_20_50cm_xtra_bz_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cx': Dataset(tag=phil_man_20_50cm_xtra_cx</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cx_val': Dataset(tag=phil_man_20_50cm_xtra_cx_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cz': Dataset(tag=phil_man_20_50cm_xtra_cz</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cz_val': Dataset(tag=phil_man_20_50cm_xtra_cz_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'potsdam': Dataset(tag=potsdam</em>, <em class="sig-param">spatial_resolution=0.05)</em>, <em class="sig-param">'sud_eldaien_19_40cm': Dataset(tag=sud_eldaien_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'sud_elgeneina_19_40cm': Dataset(tag=sud_elgeneina_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'test_jp2_shape': Dataset(tag=test_jp2_shape</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'test_tif': Dataset(tag=test_tif</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'viet_hcm_20_30cm': Dataset(tag=viet_hcm_20_30cm</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'viet_hcm_20_30cm_test': Dataset(tag=viet_hcm_20_30cm_test</em>, <em class="sig-param">spatial_resolution=0.3)}</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.get_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dataset associated with a specific string tag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tag</strong> (<em>str</em>) – An existing dataset tag, for example, “inria_austin”</p></li>
<li><p><strong>registry</strong> (<em>dict</em><em>, </em><em>optional</em>) – The registry dictionary tracking the tags of datasets added</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The dataset with the specified tag</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#gim_cv.datasets.Dataset" title="gim_cv.datasets.Dataset">Dataset</a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>KeyError:</strong> – If no dataset exists with this tag</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.get_flanders_dataset_table">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">get_flanders_dataset_table</code><span class="sig-paren">(</span><em class="sig-param">db_url=sqlite:////home/root/data/local/orthos.db</em>, <em class="sig-param">table_name='vlaanderen_ortho_datasets'</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.get_flanders_dataset_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to a database (normally local SQLite) containing a table with
webscraped data used to build datasets (file URLs, acquisition years, …)
and return a pandas dataframe of this table to be used for downloading the
linked files etc</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>db_url</strong> (<em>str</em><em>, </em><em>optional</em>) – URL to SQLite database with dataset metadata table (which is webscraped
- see scrapers)</p></li>
<li><p><strong>table_name</strong> (<em>str</em><em>, </em><em>optional</em>) – The table name for the flanders datasets in said database</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dataframe of metadata used to build datasets of remote rasters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.get_flanders_datasets">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">get_flanders_datasets</code><span class="sig-paren">(</span><em class="sig-param">db_url=sqlite:////home/root/data/local/orthos.db</em>, <em class="sig-param">table_name='vlaanderen_ortho_datasets'</em>, <em class="sig-param">table_prepare_fn=&lt;function prepare_flanders_dataset_table&gt;</em>, <em class="sig-param">img_download_dir=PosixPath('/home/root/data/volumes/ebs_inference_storage/input_rasters/vlaanderen')</em>, <em class="sig-param">file_download_fn=&lt;function download_extract_translate&gt;</em>, <em class="sig-param">overwrite=False</em>, <em class="sig-param">target_spatial_resolution=1.0</em>, <em class="sig-param">return_table=False</em>, <em class="sig-param">download_timeout=7200</em>, <em class="sig-param">**prepare_kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.get_flanders_datasets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of Dataset objects corresponding each Flemish ortho year</p>
<p>Datasets contain flanders orthophotos and their appropriate capture time,
spatial resolution etc. These have assigned methods to download the
associated archives on demand, extract them to obtain the rasters, and
optionally resample these to a target spatial resolution as a postprocessing
step.</p>
<p>The URLs and metadata used to build the datasets are defined in a SQLite
database at db_url, which is in turn built by the scraper in <cite>gim_cv.scrapers</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>db_url</strong> (<em>str</em><em>, </em><em>optional</em>) – URL to SQLite database with dataset metadata table (which is
webscraped - see <cite>gim_cv.scrapers</cite> submodule)</p></li>
<li><p><strong>table_name</strong> (<em>str</em><em>, </em><em>optional</em>) – The table name for the flanders datasets in said database</p></li>
<li><p><strong>table_prepare_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – Preprocessing function for cleaning the raw SQL table dataframe in
pandas and returning the df</p></li>
<li><p><strong>img_download_dir</strong> (str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code>, optional) – Parent directory into which to download dataset files</p></li>
<li><p><strong>file_download_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – function with signature: (save_dir, urls, filenames, timeout,
target_scales, overwrite) which is assigned as a method of the returned
Datasets so that they can download all the necessary files on demand
from the appropriate URLs. this should download and extract the raster
files and return a list of the local paths</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag controlling re-download/overwrite behaviour if raster files are
identified as already present locally</p></li>
<li><p><strong>target_spatial_resolution</strong> (<em>float</em><em> or </em><em>NoneType</em><em>, </em><em>optional</em>) – Sets the target spatial resolution which the downloaded rasters will be
automatically rescaled to.</p></li>
<li><p><strong>return_table</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flags whether to alternatively return a 2-tuple containing a dataframe
of the metadata pertaining to the rasters in each dataset, in addition
to the Dataset objects themselves.</p></li>
<li><p><strong>download_timeout</strong> (<em>int</em><em>, </em><em>optional</em>) – Downloads auto-fail after this many seconds</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>datasets</strong> – A list of Datasets, one per ortho year present, each with the download
method <cite>image_download_fn</cite> set to pull rasters from the appropriate URLs
If the return_table argument is True, return a 2-tuple with (this list,
raster metadata dataframe) for inspection.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="#gim_cv.datasets.Dataset" title="gim_cv.datasets.Dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dataset</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.get_image_inference_pipeline_by_tag">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">get_image_inference_pipeline_by_tag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tag</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.get_image_inference_pipeline_by_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns dataset-appropriate pipeline for preprocessing images for inference</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag</strong> (<em>str</em>) – The tag of the dataset for which to get the inference pipeline</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pipeline for preprocessing this dataset’s raster data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sklearn.pipeline.Pipeline</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Written in this form to allow overriding default pipelines for some datasets</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.get_image_training_pipeline_by_tag">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">get_image_training_pipeline_by_tag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tag</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.get_image_training_pipeline_by_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dataset-appropriate pipeline for preprocessing images for training</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag</strong> (<em>str</em>) – The tag of the dataset for which to get the training pipeline</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pipeline for preprocessing this dataset’s raster data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sklearn.pipeline.Pipeline</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Written in this form to allow overriding default pipelines for some datasets</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.get_wallonia_datasets">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">get_wallonia_datasets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.get_wallonia_datasets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Dataset objects pointing to the wallonia orthophotos for
each acquisition year.</p>
<p>These are expected to be present locally as there’s no convenient download
links like there are for flanders.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of <a class="reference internal" href="#gim_cv.datasets.Dataset" title="gim_cv.datasets.Dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dataset</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.list_datasets">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">list_datasets</code><span class="sig-paren">(</span><em class="sig-param">registry={'Vlaanderen_1979-1990_100cm': Dataset(tag=Vlaanderen_1979-1990_100cm</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2000-2003_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2000-2003_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2000-2003_30cm_missing_tiles_resampled_30pct': Dataset(tag=Vlaanderen_2000-2003_30cm_missing_tiles_resampled_30pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2000-2003_30cm_resampled_30pct': Dataset(tag=Vlaanderen_2000-2003_30cm_resampled_30pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2005-2007_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2005-2007_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2008-2011_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2008-2011_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2012_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2012_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2013_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2013_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2014_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2014_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2015_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2015_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2016_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2016_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2017_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2017_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2018_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2018_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_2019_25cm_resampled_25pct': Dataset(tag=Vlaanderen_2019_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Vlaanderen_meest recent_25cm_resampled_25pct': Dataset(tag=Vlaanderen_meest recent_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallona_1994-2000_40cm_missing_tiles_resampled_40pct': Dataset(tag=Wallona_1994-2000_40cm_missing_tiles_resampled_40pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_1994-2000_40cm_resampled_40pct': Dataset(tag=Wallonia_1994-2000_40cm_resampled_40pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2006-2007_50cm_resampled_50pct': Dataset(tag=Wallonia_2006-2007_50cm_resampled_50pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2009-2010_25cm_resampled_25pct': Dataset(tag=Wallonia_2009-2010_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2013_25cm_resampled_25pct': Dataset(tag=Wallonia_2013_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2015_25cm_resampled_25pct': Dataset(tag=Wallonia_2015_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'Wallonia_2019_25cm_resampled_25pct': Dataset(tag=Wallonia_2019_25cm_resampled_25pct</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'belgium_ortho_2001': Dataset(tag=belgium_ortho_2001</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2007': Dataset(tag=belgium_ortho_2007</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2009': Dataset(tag=belgium_ortho_2009</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015': Dataset(tag=belgium_ortho_2015</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra': Dataset(tag=belgium_ortho_2015_extra</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_0': Dataset(tag=belgium_ortho_2015_extra_0</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_2': Dataset(tag=belgium_ortho_2015_extra_2</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_3': Dataset(tag=belgium_ortho_2015_extra_3</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2015_extra_4': Dataset(tag=belgium_ortho_2015_extra_4</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_2016': Dataset(tag=belgium_ortho_2016</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_ortho_no_2001': Dataset(tag=belgium_ortho_no_2001</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'belgium_topo_1969': Dataset(tag=belgium_topo_1969</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'col_bar_19_40cm': Dataset(tag=col_bar_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_40cm_full': Dataset(tag=col_bar_19_40cm_full</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_40cm_test': Dataset(tag=col_bar_19_40cm_test</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_40cm_test_full': Dataset(tag=col_bar_19_40cm_test_full</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_bar_19_6cm': Dataset(tag=col_bar_19_6cm</em>, <em class="sig-param">spatial_resolution=0.06)</em>, <em class="sig-param">'col_med_19_10m': Dataset(tag=col_med_19_10m</em>, <em class="sig-param">spatial_resolution=10.0)</em>, <em class="sig-param">'col_med_19_40cm': Dataset(tag=col_med_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'col_med_19_40cm_test': Dataset(tag=col_med_19_40cm_test</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'gim': Dataset(tag=gim</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'inria': Dataset(tag=inria</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_austin': Dataset(tag=inria_austin</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_chicago': Dataset(tag=inria_chicago</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_eu': Dataset(tag=inria_eu</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_kitsap': Dataset(tag=inria_kitsap</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_tyrol': Dataset(tag=inria_tyrol</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'inria_vienna': Dataset(tag=inria_vienna</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'lux_18_1m_rgb': Dataset(tag=lux_18_1m_rgb</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'lux_18_aois_rgb': Dataset(tag=lux_18_aois_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_18_rgb': Dataset(tag=lux_18_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_1m_rgb': Dataset(tag=lux_19_1m_rgb</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'lux_19_aois_rgb': Dataset(tag=lux_19_aois_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_repeat': Dataset(tag=lux_19_repeat</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_repeat_20cm': Dataset(tag=lux_19_repeat_20cm</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_rgb': Dataset(tag=lux_19_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'lux_19_true_aois_rgb': Dataset(tag=lux_19_true_aois_rgb</em>, <em class="sig-param">spatial_resolution=0.2)</em>, <em class="sig-param">'massachusetts': Dataset(tag=massachusetts</em>, <em class="sig-param">spatial_resolution=1.0)</em>, <em class="sig-param">'nig_mak_19_10m': Dataset(tag=nig_mak_19_10m</em>, <em class="sig-param">spatial_resolution=10.0)</em>, <em class="sig-param">'nig_mak_19_50cm': Dataset(tag=nig_mak_19_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_1420_50cm': Dataset(tag=phil_man_1420_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_1420_50cm_bis': Dataset(tag=phil_man_1420_50cm_bis</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm': Dataset(tag=phil_man_14_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_01': Dataset(tag=phil_man_14_50cm_01</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_02': Dataset(tag=phil_man_14_50cm_02</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_03': Dataset(tag=phil_man_14_50cm_03</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_04': Dataset(tag=phil_man_14_50cm_04</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_14_50cm_05': Dataset(tag=phil_man_14_50cm_05</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_ne': Dataset(tag=phil_man_19_50cm_ne</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_nw': Dataset(tag=phil_man_19_50cm_nw</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_se': Dataset(tag=phil_man_19_50cm_se</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_sw': Dataset(tag=phil_man_19_50cm_sw</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_19_50cm_test': Dataset(tag=phil_man_19_50cm_test</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm': Dataset(tag=phil_man_20_50cm</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_4gp': Dataset(tag=phil_man_20_50cm_4gp</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_6gp': Dataset(tag=phil_man_20_50cm_6gp</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_bis': Dataset(tag=phil_man_20_50cm_bis</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_bis_test': Dataset(tag=phil_man_20_50cm_bis_test</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_full': Dataset(tag=phil_man_20_50cm_full</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_test': Dataset(tag=phil_man_20_50cm_test</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_tris': Dataset(tag=phil_man_20_50cm_tris</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_ax': Dataset(tag=phil_man_20_50cm_xtra_ax</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_ax_val': Dataset(tag=phil_man_20_50cm_xtra_ax_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_az': Dataset(tag=phil_man_20_50cm_xtra_az</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_az_val': Dataset(tag=phil_man_20_50cm_xtra_az_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bx': Dataset(tag=phil_man_20_50cm_xtra_bx</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bx_val': Dataset(tag=phil_man_20_50cm_xtra_bx_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bz': Dataset(tag=phil_man_20_50cm_xtra_bz</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_bz_val': Dataset(tag=phil_man_20_50cm_xtra_bz_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cx': Dataset(tag=phil_man_20_50cm_xtra_cx</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cx_val': Dataset(tag=phil_man_20_50cm_xtra_cx_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cz': Dataset(tag=phil_man_20_50cm_xtra_cz</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'phil_man_20_50cm_xtra_cz_val': Dataset(tag=phil_man_20_50cm_xtra_cz_val</em>, <em class="sig-param">spatial_resolution=0.5)</em>, <em class="sig-param">'potsdam': Dataset(tag=potsdam</em>, <em class="sig-param">spatial_resolution=0.05)</em>, <em class="sig-param">'sud_eldaien_19_40cm': Dataset(tag=sud_eldaien_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'sud_elgeneina_19_40cm': Dataset(tag=sud_elgeneina_19_40cm</em>, <em class="sig-param">spatial_resolution=0.4)</em>, <em class="sig-param">'test_jp2_shape': Dataset(tag=test_jp2_shape</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'test_tif': Dataset(tag=test_tif</em>, <em class="sig-param">spatial_resolution=0.25)</em>, <em class="sig-param">'viet_hcm_20_30cm': Dataset(tag=viet_hcm_20_30cm</em>, <em class="sig-param">spatial_resolution=0.3)</em>, <em class="sig-param">'viet_hcm_20_30cm_test': Dataset(tag=viet_hcm_20_30cm_test</em>, <em class="sig-param">spatial_resolution=0.3)}</em>, <em class="sig-param">skip_missing_files=False</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.list_datasets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the tags for all datasets currently defined in this file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>registry</strong> (<em>dict</em><em>, </em><em>optional</em>) – The registry dictionary tracking the tags of datasets added</p></li>
<li><p><strong>skip_missing_files</strong> (<em>bool</em><em>, </em><em>optional</em>) – Excludes datasets for which there are no files present locally
and no download method assigned</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tags for every dataset included</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#gim_cv.datasets.get_dataset" title="gim_cv.datasets.get_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dataset</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.prepare_flanders_dataset_table">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">prepare_flanders_dataset_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">suffix_regex</span><span class="o">=</span><span class="default_value">'(K(BL_)?)?\\d{1,2}$'</span></em>, <em class="sig-param"><span class="n">group_datasets_by</span><span class="o">=</span><span class="default_value">['region', 'period', 'scale_str']</span></em>, <em class="sig-param"><span class="n">forbid_col_regexes</span><span class="o">=</span><span class="default_value">[('download_url', '.*50cm.*')]</span></em>, <em class="sig-param"><span class="n">eyeball_check</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.prepare_flanders_dataset_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleans raw metadata table and creates dataset_id column for flanders orthos</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – A dataframe containing the SQL table with raster URLs and metadata.
Generated by the <cite>get_flanders_dataset_table</cite> function.</p></li>
<li><p><strong>suffix_regex</strong> (<em>str</em><em>, </em><em>optional</em>) – A Regex expression matching an area code in the raster filename</p></li>
<li><p><strong>group_datasets_by</strong> (<em>list of str</em><em>, </em><em>optional</em>) – Columns by which to group the rasters, forming dataset tags by each
unique combination of these</p></li>
<li><p><strong>forbid_col_regexes</strong> (<em>list of</em><em> (</em><em>str</em><em>, </em><em>str</em><em>)</em>) – List specifying (column, pattern) pairs, such that any entries in column
which match pattern will be ignored</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A cleaned dataframe of raster metadata with a dataset_id column used to
collect rasters into datasets to be downloaded</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.datasets.sorted_files_matching">
<code class="sig-prename descclassname">gim_cv.datasets.</code><code class="sig-name descname">sorted_files_matching</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">directory</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.datasets.sorted_files_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sorted list of the files in a given directory which match a regex</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> (<em>str</em>) – A regex pattern for the filenames (not including parent dirs)</p></li>
<li><p><strong>directory</strong> (str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code>) – The directory in which to search</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code> objects corresponding to the matching files</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-gim_cv.exceptions">
<span id="gim-cv-exceptions-module"></span><h2>gim_cv.exceptions module<a class="headerlink" href="#module-gim_cv.exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="py exception">
<dt id="gim_cv.exceptions.InvalidArrayError">
<em class="property">exception </em><code class="sig-prename descclassname">gim_cv.exceptions.</code><code class="sig-name descname">InvalidArrayError</code><a class="headerlink" href="#gim_cv.exceptions.InvalidArrayError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.inference">
<span id="gim-cv-inference-module"></span><h2>gim_cv.inference module<a class="headerlink" href="#module-gim_cv.inference" title="Permalink to this headline">¶</a></h2>
<p>Inference</p>
<p>This module provides high-level classes for creating image datasets and running
inference on them using a tensorflow.keras model (which implements fit and
accepts input of shape (batch * height * width * channels)).</p>
<p class="rubric">Examples</p>
<p>A very simple end to end example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="c1"># assuming you have a tf.keras model defined somewhere along with a</span>
<span class="o">&gt;&gt;</span> <span class="c1"># function which returns a pipeline which preprocesses image files</span>
<span class="o">&gt;&gt;</span> <span class="c1"># into (b,  h, w, c)</span>
<span class="o">&gt;&gt;</span> <span class="kn">from</span> <span class="nn">models</span> <span class="kn">import</span> <span class="n">my_model</span>
<span class="o">&gt;&gt;</span> <span class="kn">from</span> <span class="nn">preprocessing</span> <span class="kn">import</span> <span class="n">get_pipeline</span>
<span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;</span> <span class="c1"># say you have a bunch of tifs with the same size in this directory</span>
<span class="o">&gt;&gt;</span> <span class="n">image_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="o">./</span><span class="n">data</span><span class="o">/</span><span class="n">my_image_dataset</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;\*.tif&#39;</span><span class="p">)]</span>
<span class="o">&gt;&gt;</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">InferenceDataset</span><span class="p">(</span><span class="n">image_paths</span><span class="p">,</span> <span class="n">image_pipeline_factory</span><span class="o">=</span><span class="n">get_pipeline</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="c1"># queue up necessary preprocessing and batching operations on files</span>
<span class="o">&gt;&gt;</span> <span class="n">ids</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>
<span class="o">&gt;&gt;</span> <span class="c1"># queue up GPU inference, initialise interfaces to write output files</span>
<span class="o">&gt;&gt;</span> <span class="n">ids</span><span class="o">.</span><span class="n">schedule_inference</span><span class="p">(</span><span class="n">my_model</span><span class="p">,</span> <span class="n">output_directory</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="s1">&#39;./output_masks&#39;</span><span class="p">))</span>
<span class="o">&gt;&gt;</span> <span class="c1"># run inference and write output masks</span>
<span class="o">&gt;&gt;</span> <span class="n">ids</span><span class="o">.</span><span class="n">write_mask_rasters</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Section breaks are created with two blank lines. Section breaks are also
implicitly created anytime a new section starts. Section bodies <em>may</em> be
indented:</p>
<p class="rubric">Notes</p>
<p>This is an example of an indented section. It’s like any other section,
but the body is indented to help it stand out from surrounding text.</p>
<p>If a section is indented, then a section break is created by
resuming unindented text.</p>
<dl class="py attribute">
<dt id="gim_cv.inference.module_level_variable1">
<code class="sig-prename descclassname">gim_cv.inference.</code><code class="sig-name descname">module_level_variable1</code><a class="headerlink" href="#gim_cv.inference.module_level_variable1" title="Permalink to this definition">¶</a></dt>
<dd><p>Module level variables may be documented in either the <code class="docutils literal notranslate"><span class="pre">Attributes</span></code>
section of the module docstring, or in an inline docstring immediately
following the variable.</p>
<p>Either form is acceptable, but the two should not be mixed. Choose
one convention to document module level variables and be consistent
with it.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="gim_cv.inference.BaseInferenceDataset">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.inference.</code><code class="sig-name descname">BaseInferenceDataset</code><a class="headerlink" href="#gim_cv.inference.BaseInferenceDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Implements common methods for single- and multi-raster
(Composite)InferenceDataset objects.</p>
</dd></dl>

<dl class="py class">
<dt id="gim_cv.inference.CompositeInferenceDataset">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.inference.</code><code class="sig-name descname">CompositeInferenceDataset</code><span class="sig-paren">(</span><em class="sig-param">constituents=[]</em>, <em class="sig-param">prune_fn=&lt;function has_empty_raster&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gim_cv.inference.BaseInferenceDataset" title="gim_cv.inference.BaseInferenceDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">gim_cv.inference.BaseInferenceDataset</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Interface to multiple InferenceDatasets (e.g. with different source rasters).
Provides methods to apply preprocessing and inference with a given model
on a set of input rasters independently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>constituents</strong> (<em>list</em><em>, </em><em>optional</em>) – A list of InferenceDatasets</p></li>
<li><p><strong>prune_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – A callable which accepts a TrainingDataset, performs some calculation
and returns True if it’s to be removed from the constituents else False.
Used for eliminating rasters which are e.g. empty (all 255s).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.cache_mask_array_tiles">
<code class="sig-name descname">cache_mask_array_tiles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.cache_mask_array_tiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="gim_cv.inference.CompositeInferenceDataset.composition_prepared">
<code class="sig-name descname">composition_prepared</code><em class="property"> = False</em><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.composition_prepared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.constituent_datasets_by_tag">
<code class="sig-name descname">constituent_datasets_by_tag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tag</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.constituent_datasets_by_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.delete_input_rasters">
<code class="sig-name descname">delete_input_rasters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.delete_input_rasters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.prepare">
<code class="sig-name descname">prepare</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">validate</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.prepared">
<em class="property">property </em><code class="sig-name descname">prepared</code><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.prepared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.prune">
<code class="sig-name descname">prune</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls prune_fn (if set) on each constituent dataset and removes it from the
constituents list if this function returns True.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.schedule_inference">
<code class="sig-name descname">schedule_inference</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.schedule_inference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.tags">
<em class="property">property </em><code class="sig-name descname">tags</code><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.tags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.tags_str">
<em class="property">property </em><code class="sig-name descname">tags_str</code><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.tags_str" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.CompositeInferenceDataset.write_mask_rasters">
<code class="sig-name descname">write_mask_rasters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">skip_failures</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.CompositeInferenceDataset.write_mask_rasters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.inference.InferenceDataset">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.inference.</code><code class="sig-name descname">InferenceDataset</code><span class="sig-paren">(</span><em class="sig-param">image_src</em>, <em class="sig-param">image_pipeline_factory=&lt;function get_image_inference_pipeline&gt;</em>, <em class="sig-param">mask_tar=None</em>, <em class="sig-param">image_validation_function=None</em>, <em class="sig-param">tag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gim_cv.inference.BaseInferenceDataset" title="gim_cv.inference.BaseInferenceDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">gim_cv.inference.BaseInferenceDataset</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Facilitates running segmentation inference with a model on an input raster.</p>
<p>Handles preprocessing, segmenting patches, reassembling the segmented patches
and writing output to a new mask raster file with the georeferencing of the input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_src</strong> – A str or Path object pointing to an image file to be segmented</p></li>
<li><p><strong>image_pipeline_factory</strong> (<em>optional</em>) – A function which returns a pipeline to convert image dask array into
preprocessed patches ready for inference</p></li>
<li><p><strong>mask_tar</strong> (<em>optional</em>) – Optionally specify the file to write the segmentation results to.
If this isn’t set a directory can be set instead later (see
<a class="reference internal" href="#gim_cv.inference.InferenceDataset.schedule_inference" title="gim_cv.inference.InferenceDataset.schedule_inference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">schedule_inference()</span></code></a>) and
a reasonable output file name will be generated based on the input raster
and the model uuid used for inference.</p></li>
<li><p><strong>image_validation_function</strong> (<em>optional</em>) – Specifies a function which should accept the input image array, calculate
some quantity and return True if valid and False if invalid.</p></li>
<li><p><strong>tag</strong> (<em>optional</em>) – String tag corresponding to the Dataset to which the input image belongs.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.X">
<em class="property">property </em><code class="sig-name descname">X</code><a class="headerlink" href="#gim_cv.inference.InferenceDataset.X" title="Permalink to this definition">¶</a></dt>
<dd><p>processed input image array</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.delete_input_raster">
<code class="sig-name descname">delete_input_raster</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.delete_input_raster" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.get_X">
<code class="sig-name descname">get_X</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.get_X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.get_y">
<code class="sig-name descname">get_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.get_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="gim_cv.inference.InferenceDataset.inferred">
<code class="sig-name descname">inferred</code><em class="property"> = False</em><a class="headerlink" href="#gim_cv.inference.InferenceDataset.inferred" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.load_input_array">
<code class="sig-name descname">load_input_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.load_input_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.make_pipeline">
<code class="sig-name descname">make_pipeline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.make_pipeline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.mask_tar">
<em class="property">property </em><code class="sig-name descname">mask_tar</code><a class="headerlink" href="#gim_cv.inference.InferenceDataset.mask_tar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.prepare">
<code class="sig-name descname">prepare</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">validate</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to prepare data for feeding to model</p>
<p>Loads image/mask arrays (with cache-reliance behaviour deferred to config
via use_cache attr of readers), then applies some preprocessing pipeline’s
fit_transform method to the image/mask arrays</p>
<p>Can skip pipeline step by explicitly setting pipeline = None</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>validate</strong> – Boolean flag. If True, first runs image_validation_function on the input
raster array and raises an exception if it returns False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.inference.InferenceDataset.prepared">
<code class="sig-name descname">prepared</code><em class="property"> = False</em><a class="headerlink" href="#gim_cv.inference.InferenceDataset.prepared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.schedule_inference">
<code class="sig-name descname">schedule_inference</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span><span class="p">:</span> <span class="n">tensorflow.python.keras.engine.training.Model</span></em>, <em class="sig-param"><span class="n">output_directory</span><span class="p">:</span> <span class="n">pathlib.Path</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.schedule_inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dask array containing segmentation masks for patches of input.</p>
<p>This method maps the tf.keras model passed to it over the input patches,
(using a batch size of 1 which aligns with the input patch chunking)
creating a lazy segmented patch array (assigned to y).</p>
<p>If no mask_tar output file has been specified, this will be set automatically
to: output_directory / image_src _ model_name _ model_checkpoint_uuid</p>
<p>Does <em>not</em> yet compute the segmentation itself (see
<a class="reference internal" href="#gim_cv.inference.InferenceDataset.write_mask_raster" title="gim_cv.inference.InferenceDataset.write_mask_raster"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_mask_raster()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – A tensorflow.keras segmentation model that expects batches of patches
of shape: (b, h, w, c)</p></li>
<li><p><strong>output_directory</strong> – A path to a directory where the output raster should be written (if the
path to the exact output file hasn’t been specified by setting mask_tar).
The output raster will appear in this directory with a reasonable automatically
generated name.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.inference.InferenceDataset.tile_axis">
<code class="sig-name descname">tile_axis</code><em class="property"> = 0</em><a class="headerlink" href="#gim_cv.inference.InferenceDataset.tile_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.validate_input_array">
<code class="sig-name descname">validate_input_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.validate_input_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.write_mask_raster">
<code class="sig-name descname">write_mask_raster</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.InferenceDataset.write_mask_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the segmentation mask and writes it to the specified output raster.</p>
<p>Runs inference on each patch of the raster, reassembles these into the full
raster shape and outputs to <code class="docutils literal notranslate"><span class="pre">.tif</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>overwrite</strong> – Boolean flag to control whether to skip inference if the mask_tar file
already exists.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.y">
<em class="property">property </em><code class="sig-name descname">y</code><a class="headerlink" href="#gim_cv.inference.InferenceDataset.y" title="Permalink to this definition">¶</a></dt>
<dd><p>processed output mask array</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.inference.InferenceDataset.y_chunks">
<em class="property">property </em><code class="sig-name descname">y_chunks</code><a class="headerlink" href="#gim_cv.inference.InferenceDataset.y_chunks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="gim_cv.inference.has_empty_raster">
<code class="sig-prename descclassname">gim_cv.inference.</code><code class="sig-name descname">has_empty_raster</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ids</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#gim_cv.inference.InferenceDataset" title="gim_cv.inference.InferenceDataset">gim_cv.inference.InferenceDataset</a></span></em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#gim_cv.inference.has_empty_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if an training dataset image array is all 255s,
i.e. an empty raster. Loads the array interfaces in order to compute this.</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.inference.predict_on_batch_workaround">
<code class="sig-prename descclassname">gim_cv.inference.</code><code class="sig-name descname">predict_on_batch_workaround</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">batch</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.predict_on_batch_workaround" title="Permalink to this definition">¶</a></dt>
<dd><p>WORKAROUND FOR MEMORY LEAK
<a class="reference external" href="https://github.com/tensorflow/tensorflow/issues/33009">https://github.com/tensorflow/tensorflow/issues/33009</a>
<a class="reference external" href="https://github.com/keras-team/keras/issues/13118">https://github.com/keras-team/keras/issues/13118</a></p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.inference.tar_mask_path">
<code class="sig-prename descclassname">gim_cv.inference.</code><code class="sig-name descname">tar_mask_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image_src</span></em>, <em class="sig-param"><span class="n">model_str</span></em>, <em class="sig-param"><span class="n">ext</span><span class="o">=</span><span class="default_value">'tif'</span></em>, <em class="sig-param"><span class="n">resample_sf</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">directory</span><span class="o">=</span><span class="default_value">'/home/root/data/volumes/ebs_inference_storage/binary_mask_rasters'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.inference.tar_mask_path" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a target mask file from image path, model id string, extension and target dir</p>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.losses">
<span id="gim-cv-losses-module"></span><h2>gim_cv.losses module<a class="headerlink" href="#module-gim_cv.losses" title="Permalink to this headline">¶</a></h2>
<p>losses.py</p>
<p>Contains loss functions used in training machine learing models throughout</p>
<p><a class="reference external" href="https://lars76.github.io/neural-networks/object-detection/losses-for-segmentation/">https://lars76.github.io/neural-networks/object-detection/losses-for-segmentation/</a></p>
<p>and the paper</p>
<p><a class="reference external" href="https://arxiv.org/abs/1810.07842">https://arxiv.org/abs/1810.07842</a></p>
<dl class="py class">
<dt id="gim_cv.losses.AlphaScheduler">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">AlphaScheduler</code><a class="headerlink" href="#gim_cv.losses.AlphaScheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.keras.callbacks.Callback</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Element of surface loss defined in:
<a class="reference external" href="http://proceedings.mlr.press/v102/kervadec19a/kervadec19a.pdf">http://proceedings.mlr.press/v102/kervadec19a/kervadec19a.pdf</a>
<a class="reference external" href="https://github.com/LIVIAETS/surface-loss/issues/14#issuecomment-546342163">https://github.com/LIVIAETS/surface-loss/issues/14#issuecomment-546342163</a></p>
<p>pass alpha as: alpha = K.variable(1, dtype=’float32’)
pass update_alpha as update fn</p>
<dl class="py method">
<dt id="gim_cv.losses.AlphaScheduler.init">
<code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">update_fn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.AlphaScheduler.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.losses.AlphaScheduler.on_epoch_end">
<code class="sig-name descname">on_epoch_end</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">epoch</span></em>, <em class="sig-param"><span class="n">logs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.AlphaScheduler.on_epoch_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Called at the end of an epoch.</p>
<p>Subclasses should override for any actions to run. This function should only
be called during TRAIN mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>epoch</strong> – integer, index of epoch.</p></li>
<li><p><strong>logs</strong> – dict, metric results for this training epoch, and for the
validation epoch if validation is performed. Validation result keys
are prefixed with <cite>val_</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.bbce_adaptive">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">bbce_adaptive</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.bbce_adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>version that precalculates a weight for each class
<a class="reference external" href="https://arxiv.org/pdf/1707.03237.pdf">https://arxiv.org/pdf/1707.03237.pdf</a> (pretty sure they mean r_n instead of p_n)
to balance class freqs (see ‘w_c’ in )
<a class="reference external" href="https://arxiv.org/pdf/1505.04597.pdf">https://arxiv.org/pdf/1505.04597.pdf</a></p>
<p>normalises weights st pos_wgt + neg_wgt  = 1.
see <a class="reference external" href="https://lars76.github.io/neural-networks/object-detection/losses-for-segmentation/">https://lars76.github.io/neural-networks/object-detection/losses-for-segmentation/</a>
balanced cross entropy</p>
<p>this can sometimes go negative with current log setup?</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.bce_dice_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">bce_dice_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.bce_dice_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.binary_crossentropy_from_logits">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">binary_crossentropy_from_logits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.binary_crossentropy_from_logits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.calc_dist_map">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">calc_dist_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.calc_dist_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Element of surface loss defined in:
<a class="reference external" href="http://proceedings.mlr.press/v102/kervadec19a/kervadec19a.pdf">http://proceedings.mlr.press/v102/kervadec19a/kervadec19a.pdf</a>
<a class="reference external" href="https://github.com/LIVIAETS/surface-loss/issues/14#issuecomment-546342163">https://github.com/LIVIAETS/surface-loss/issues/14#issuecomment-546342163</a></p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.calc_dist_map_batch">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">calc_dist_map_batch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.calc_dist_map_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Element of surface loss defined in:
<a class="reference external" href="http://proceedings.mlr.press/v102/kervadec19a/kervadec19a.pdf">http://proceedings.mlr.press/v102/kervadec19a/kervadec19a.pdf</a>
<a class="reference external" href="https://github.com/LIVIAETS/surface-loss/issues/14#issuecomment-546342163">https://github.com/LIVIAETS/surface-loss/issues/14#issuecomment-546342163</a></p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.class_weighted_pixelwise_crossentropy">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">class_weighted_pixelwise_crossentropy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sample_weights</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.class_weighted_pixelwise_crossentropy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.dice_coeff_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">dice_coeff_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.dice_coeff_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.dice_coefficient">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">dice_coefficient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.dice_coefficient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.dice_focal_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">dice_focal_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lambda_</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">gamma</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.dice_focal_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.dice_sens_mae_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">dice_sens_mae_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.dice_sens_mae_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.dsc">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">dsc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.dsc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.flatten_binary_scores">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">flatten_binary_scores</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scores</span></em>, <em class="sig-param"><span class="n">labels</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.flatten_binary_scores" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens predictions in the batch (binary case)
Remove labels equal to ‘ignore’</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.flatten_probas">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">flatten_probas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">probas</span></em>, <em class="sig-param"><span class="n">labels</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'BHWC'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.flatten_probas" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens predictions in the batch</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.focal_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">focal_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">gamma</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.focal_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>The novel Focal Loss focuses training on a sparse set of hard examples and prevents the vast number of easy negatives from overwhelming the detector during training
<a class="reference external" href="https://arxiv.org/abs/1708.02002v2">https://arxiv.org/abs/1708.02002v2</a></p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.focal_tversky_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">focal_tversky_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">gamma</span><span class="o">=</span><span class="default_value">1.3333333333333333</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.focal_tversky_loss" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://arxiv.org/pdf/1810.07842.pdf">https://arxiv.org/pdf/1810.07842.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.jaccard_index">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">jaccard_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.jaccard_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.lovasz_grad">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">lovasz_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gt_sorted</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.lovasz_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes gradient of the Lovasz extension w.r.t sorted errors
See Alg. 1 in paper</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.lovasz_hinge">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">lovasz_hinge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logits</span></em>, <em class="sig-param"><span class="n">labels</span></em>, <em class="sig-param"><span class="n">per_image</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.lovasz_hinge" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Binary Lovasz hinge loss</dt><dd><p>logits: [B, H, W] Variable, logits at each pixel (between -infty and +infty)
labels: [B, H, W] Tensor, binary ground truth masks (0 or 1)
per_image: compute the loss per image instead of per batch
ignore: void class id</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.lovasz_hinge_flat">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">lovasz_hinge_flat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logits</span></em>, <em class="sig-param"><span class="n">labels</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.lovasz_hinge_flat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Binary Lovasz hinge loss</dt><dd><p>logits: [P] Variable, logits at each prediction (between -infty and +infty)
labels: [P] Tensor, binary ground truth labels (0 or 1)
ignore: label to ignore</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.lovasz_hinge_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">lovasz_hinge_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.lovasz_hinge_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.lovasz_softmax">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">lovasz_softmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">probas</span></em>, <em class="sig-param"><span class="n">labels</span></em>, <em class="sig-param"><span class="n">classes</span><span class="o">=</span><span class="default_value">'present'</span></em>, <em class="sig-param"><span class="n">per_image</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'BHWC'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.lovasz_softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-class Lovasz-Softmax loss</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probas</strong> – [B, H, W, C] or [B, C, H, W] Variable, class probabilities at each prediction (between 0 and 1)
Interpreted as binary (sigmoid) output with outputs of size [B, H, W].</p></li>
<li><p><strong>labels</strong> – [B, H, W] Tensor, ground truth labels (between 0 and C - 1)</p></li>
<li><p><strong>classes</strong> – ‘all’ for all, ‘present’ for classes present in labels, or a list of classes to average.</p></li>
<li><p><strong>per_image</strong> – compute the loss per image instead of per batch</p></li>
<li><p><strong>ignore</strong> – void class labels</p></li>
<li><p><strong>order</strong> – use BHWC or BCHW</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.lovasz_softmax_flat">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">lovasz_softmax_flat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">probas</span></em>, <em class="sig-param"><span class="n">labels</span></em>, <em class="sig-param"><span class="n">classes</span><span class="o">=</span><span class="default_value">'present'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.lovasz_softmax_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-class Lovasz-Softmax loss</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probas</strong> – [P, C] Variable, class probabilities at each prediction (between 0 and 1)</p></li>
<li><p><strong>labels</strong> – [P] Tensor, ground truth labels (between 0 and C - 1)</p></li>
<li><p><strong>classes</strong> – ‘all’ for all, ‘present’ for classes present in labels, or a list of classes to average.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.mean_absolute_error">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">mean_absolute_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.mean_absolute_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.npv">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">npv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.npv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.precision">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">precision</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.precision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.recall">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">recall</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.recall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.sensitivity_coef">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">sensitivity_coef</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">smooth</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.sensitivity_coef" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.sensitivity_coef_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">sensitivity_coef_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.sensitivity_coef_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.specificity">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">specificity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.specificity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.surface_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">surface_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.surface_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.tanimoto_coefficient">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">tanimoto_coefficient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.tanimoto_coefficient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.tn">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">tn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.tn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.tp">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">tp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.tp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.tversky_index">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">tversky_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.3</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.tversky_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tversky Index, a generalization of the Dice score which allows
flexibility in the relative weighting of the importance of
minimising FPs and FNs in training.</p>
<p>Reproduces the dice coefficient and tanimoto coefficient/jaccard index
as special cases</p>
<p>Signature:</p>
<blockquote>
<div><p>alpha: floating to weight contribution of false negatives
beta: float to weight contribution of false positives
smooth: numerical smoothing factor</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.tversky_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">tversky_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.tversky_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.tversky_loss_tunable">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">tversky_loss_tunable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.9</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.tversky_loss_tunable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.update_alpha">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">update_alpha</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.update_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.wbce_adaptive">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">wbce_adaptive</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.wbce_adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>version that precalculates a weight map for each image
<a class="reference external" href="https://arxiv.org/pdf/1707.03237.pdf">https://arxiv.org/pdf/1707.03237.pdf</a> (pretty sure they mean r_n instead of p_n)
to balance class freqs (see ‘w_c’ in )
<a class="reference external" href="https://arxiv.org/pdf/1505.04597.pdf">https://arxiv.org/pdf/1505.04597.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.wbce_adaptive_dice_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">wbce_adaptive_dice_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">lambda_</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.wbce_adaptive_dice_loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.weighted_binary_crossentropy">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">weighted_binary_crossentropy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_wgt</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.weighted_binary_crossentropy" title="Permalink to this definition">¶</a></dt>
<dd><p>version with a fixed weight for the whole dataset</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.losses.weighted_wbce_adaptive_dice_loss">
<code class="sig-prename descclassname">gim_cv.losses.</code><code class="sig-name descname">weighted_wbce_adaptive_dice_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lambda_</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-07</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.losses.weighted_wbce_adaptive_dice_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>lambda * weighted bce loss + dice coeff</p>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.metrics">
<span id="gim-cv-metrics-module"></span><h2>gim_cv.metrics module<a class="headerlink" href="#module-gim_cv.metrics" title="Permalink to this headline">¶</a></h2>
<p>metrics.py</p>
<p>Contains metrics (loss functions) used in training machine learing models throughout</p>
<p><a class="reference external" href="https://lars76.github.io/neural-networks/object-detection/losses-for-segmentation/">https://lars76.github.io/neural-networks/object-detection/losses-for-segmentation/</a></p>
<p>and the paper</p>
<p><a class="reference external" href="https://arxiv.org/abs/1810.07842">https://arxiv.org/abs/1810.07842</a></p>
<dl class="py function">
<dt id="gim_cv.metrics.dice_coefficient">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">dice_coefficient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.dice_coefficient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.metrics.jaccard_index">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">jaccard_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.jaccard_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.metrics.npv">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">npv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.npv" title="Permalink to this definition">¶</a></dt>
<dd><p>The NPV statistic, TN/TN+FN</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of ground truth binary label values in {0, 1}</p></li>
<li><p><strong>y_pred</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of predicted probabilities of belonging to these labels</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance parameter to avoid division by zero</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The NPV value in [0, 1]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.metrics.precision">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">precision</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>The Precision statistic, TP/TP+FP</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of ground truth binary label values in {0, 1}</p></li>
<li><p><strong>y_pred</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of predicted probabilities of belonging to these labels</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance parameter to avoid division by zero</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The precision value in [0, 1]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.metrics.recall">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">recall</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.recall" title="Permalink to this definition">¶</a></dt>
<dd><p>The Recall statistic, TP/TP+FN</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of ground truth binary label values in {0, 1}</p></li>
<li><p><strong>y_pred</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of predicted probabilities of belonging to these labels</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance parameter to avoid division by zero</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The recall value in [0, 1]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.metrics.specificity">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">specificity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.specificity" title="Permalink to this definition">¶</a></dt>
<dd><p>The Specificity statistic, TN/TN+FP</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of ground truth binary label values in {0, 1}</p></li>
<li><p><strong>y_pred</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – An array of predicted probabilities of belonging to these labels</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance parameter to avoid division by zero</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The specificity value in [0, 1]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.metrics.tanimoto_coefficient">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">tanimoto_coefficient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.tanimoto_coefficient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.metrics.tversky_index">
<code class="sig-prename descclassname">gim_cv.metrics.</code><code class="sig-name descname">tversky_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_pred</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">0.3</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-09</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.metrics.tversky_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tversky Index metric for segmentation</p>
<p>A generalization of the Dice score which allows flexibility in the
relative weighting of the importance of FPs and FNs</p>
<p>Reproduces the dice coefficient and tanimoto coefficient/jaccard index
as special cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> – weight for contribution of false negatives</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – weight for contribution of false positives</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – numerical smoothing factor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tversky index value in [0, 1]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.orchestration">
<span id="gim-cv-orchestration-module"></span><h2>gim_cv.orchestration module<a class="headerlink" href="#module-gim_cv.orchestration" title="Permalink to this headline">¶</a></h2>
<p>Contains utilities for orchestration tasks, such as downloading files, calling
Bash utilities to extract archives and move files around and so on.</p>
<dl class="py function">
<dt id="gim_cv.orchestration.create_loop">
<code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">create_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.create_loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.download_extract_translate">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">download_extract_translate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">urls</span></em>, <em class="sig-param"><span class="n">filenames</span></em>, <em class="sig-param"><span class="n">save_dir</span></em>, <em class="sig-param"><span class="n">target_scales</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">concurrent_download_tasks</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">concurrent_extract_jobs</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">delete_originals</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">7200</span></em>, <em class="sig-param"><span class="n">tols</span><span class="o">=</span><span class="default_value">repeat(0.01)</span></em>, <em class="sig-param"><span class="n">chunk_size</span><span class="o">=</span><span class="default_value">512000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.download_extract_translate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.download_extract_translate_sync">
<code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">download_extract_translate_sync</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">notebook</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.download_extract_translate_sync" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.download_file">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">download_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_url</span></em>, <em class="sig-param"><span class="n">save_path</span></em>, <em class="sig-param"><span class="n">session</span></em>, <em class="sig-param"><span class="n">chunk_size</span><span class="o">=</span><span class="default_value">512000</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">7200</span></em>, <em class="sig-param"><span class="n">use_temp_filename</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.download_file" title="Permalink to this definition">¶</a></dt>
<dd><p>coroutine to download a file in chunks of chunk_size at a given url,
saving to save_path</p>
<p>returns the file path upon completion for convenience</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.download_files">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">download_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">urls</span></em>, <em class="sig-param"><span class="n">save_paths</span></em>, <em class="sig-param"><span class="n">session</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">concurrent_download_tasks</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">7200</span></em>, <em class="sig-param"><span class="n">chunk_size</span><span class="o">=</span><span class="default_value">512000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.download_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.download_images_to_directory">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">download_images_to_directory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_urls</span></em>, <em class="sig-param"><span class="n">target_directory</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.download_images_to_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple example implementation where we define a coroutine
which downloads all the files in a list of URLs file_urls and saves
these to target_directory</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.download_worker">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">download_worker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">queue</span></em>, <em class="sig-param"><span class="n">dlq</span></em>, <em class="sig-param"><span class="n">session</span></em>, <em class="sig-param"><span class="n">succeeded</span></em>, <em class="sig-param"><span class="n">chunk_size</span><span class="o">=</span><span class="default_value">512000</span></em>, <em class="sig-param"><span class="n">timeout</span><span class="o">=</span><span class="default_value">7200</span></em>, <em class="sig-param"><span class="n">on_fail_slowdown</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">use_temp_filename</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.download_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>read url and path from queue, perform download request and insert
path to downloaded file to the succeeded list</p>
<p>in case of an issue, add url land save path to DLQ, sleep then
go to next url in queue</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.extract_and_translate">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">extract_and_translate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">archive_paths</span></em>, <em class="sig-param"><span class="n">target_scales</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">delete_originals</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tols</span><span class="o">=</span><span class="default_value">repeat(0.01)</span></em>, <em class="sig-param"><span class="n">concurrent_extract_jobs</span><span class="o">=</span><span class="default_value">8</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.extract_and_translate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.extract_rasters_and_translate">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">extract_rasters_and_translate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">archive_path</span></em>, <em class="sig-param"><span class="n">target_scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">delete_originals</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.extract_rasters_and_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a zip archive, identifies raster files therein and applies
GDAL translate to resample these to target_scale m spatial resolution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>archive_path</strong> – Path to zip file</p></li>
<li><p><strong>target_scale</strong> – Target spatial resolution to resample to</p></li>
<li><p><strong>overwrite</strong> – Boolean flag to toggle overwriting existing rasters with same name</p></li>
<li><p><strong>delete_originals</strong> – Boolean flag to get rid of un-resampled rasters from zip to save space</p></li>
<li><p><strong>tol</strong> – Fractional margin of error on spatial resolution with respect to the
target spatial resolution beyond which the raster will be resampled</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">resampled_rasters</span> <span class="o">=</span> <span class="k">await</span> <span class="n">extract_raster_and_translate</span><span class="p">(</span>
<span class="go">    &#39;/home/root/data/raw/vlaanderen/OKZRGB79_90VL_K01.zip&#39;,</span>
<span class="go">        overwrite=True</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.extract_translate_worker">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">extract_translate_worker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">queue</span></em>, <em class="sig-param"><span class="n">succeeded</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">delete_originals</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.extract_translate_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>execute unzip + translate jobs on queue</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.extract_zipfile">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">extract_zipfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">delete_archive</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_raster_list_only</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">raise_if_no_rasters_found</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.extract_zipfile" title="Permalink to this definition">¶</a></dt>
<dd><p>await extract_zipfile(‘./data/OKZRGB79_90VL_K01.zip’, overwrite=True)</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.gdal_translate">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">gdal_translate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_raster_path</span></em>, <em class="sig-param"><span class="n">target_extension</span><span class="o">=</span><span class="default_value">'.tif'</span></em>, <em class="sig-param"><span class="n">target_scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">delete_originals</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.gdal_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>run gdal_translate in a shell to convert a raster to a selected format,
optionally rescaling it in the process if scale_factor within tol of 1</p>
<p>target_scale is a scale factor for the spatial resolution</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.handle_failed_worker">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">handle_failed_worker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dlq</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.handle_failed_worker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.open_subprocess">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">open_subprocess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cmd_text</span></em>, <em class="sig-param"><span class="n">poll_period</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">log_errors</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">error_log</span><span class="o">=</span><span class="default_value">'/home/root/cmd_errs.log'</span></em>, <em class="sig-param"><span class="n">cmd_log</span><span class="o">=</span><span class="default_value">'/home/root/cmd.log'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.open_subprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>workaround async subprocess (asyncio subbprocess_shell hangs on communicate)</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.produce">
<em class="property">async </em><code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">produce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">queue</span></em>, <em class="sig-param"><span class="n">items</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.produce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="gim_cv.orchestration.select_rasters">
<code class="sig-prename descclassname">gim_cv.orchestration.</code><code class="sig-name descname">select_rasters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">paths</span></em>, <em class="sig-param"><span class="n">allow_multiple_rasters</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">raise_if_none_found</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.orchestration.select_rasters" title="Permalink to this definition">¶</a></dt>
<dd><p>pick out a unique tiff (high prio) or jp2 (low prio) file from
a list of files. throw an exception if no rasters.
used for unzipping archives.</p>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.preprocessing">
<span id="gim-cv-preprocessing-module"></span><h2>gim_cv.preprocessing module<a class="headerlink" href="#module-gim_cv.preprocessing" title="Permalink to this headline">¶</a></h2>
<p>preprocessing.py</p>
<p>Provides preprocessing transformations conforming to the sklearn
Transformer API and auxiliary functions for preparing raster/image data for
machine learning operations.</p>
<p>Main high-level interfaces are currently training and inference pipelines for
semantic segmentation (see <cite>get_image_training_pipeline</cite>), along with
generators for image augmentation (see e.g. <cite>get_fancy_aug_datagen</cite>).</p>
<dl class="py class">
<dt id="gim_cv.preprocessing.ArrayPadder">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">ArrayPadder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_rows</span></em>, <em class="sig-param"><span class="n">min_cols</span></em>, <em class="sig-param"><span class="n">constant_values</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ArrayPadder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Transformer to pad an image array up to a certain shape with constant values</p>
<p>Pad an array at the end of each of the first two dimensions with constant values
such that each of these is at least min_rows, min_cols respectively</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_rows</strong> (<em>int</em>) – the minimum number of acceptable rows in the output</p></li>
<li><p><strong>max_cols</strong> (<em>int</em>) – the minimum number of acceptable cols in the output</p></li>
<li><p><strong>constant_values</strong> (<em>int</em><em>, </em><em>optional</em>) – the values to pad with</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.ArrayPadder.padding_rows_">
<code class="sig-name descname">padding_rows_</code><a class="headerlink" href="#gim_cv.preprocessing.ArrayPadder.padding_rows_" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows which are padded. requires fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.ArrayPadder.padding_cols_">
<code class="sig-name descname">padding_cols_</code><a class="headerlink" href="#gim_cv.preprocessing.ArrayPadder.padding_cols_" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols which are padded. requires fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.ArrayPadder.pad_width_">
<code class="sig-name descname">pad_width_</code><a class="headerlink" href="#gim_cv.preprocessing.ArrayPadder.pad_width_" title="Permalink to this definition">¶</a></dt>
<dd><p>the calculated pad_width shape parameter passed to np.pad</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>If used on an array from a raster, the choice of using the end of each dim
will not shift the origin (top left), so the geotransform is unchanged</p>
<dl class="py method">
<dt id="gim_cv.preprocessing.ArrayPadder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ArrayPadder.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.ArrayPadder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ArrayPadder.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.BinariserRGB">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">BinariserRGB</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target_rgb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.BinariserRGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer which binarises an image/mask where channels match target_rgb</p>
<p>Elements where the last axis matches the specified <cite>target_rgb</cite> param will
become 1, otherwise zero.</p>
<p>Works for Dask or Numpy arrays.</p>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.BinariserRGB.target_rgb">
<code class="sig-name descname">target_rgb</code><a class="headerlink" href="#gim_cv.preprocessing.BinariserRGB.target_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>constant vector representing the last axis of an array, typically a
3-channel RGB value</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.BinariserRGB.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.BinariserRGB.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.BinariserRGB.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.BinariserRGB.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.ChannelSelector">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">ChannelSelector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">[0, 1, 2]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ChannelSelector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Transformer to select channels / project out slices along last axis of array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>channels</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Indices of channels to select</p>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.preprocessing.ChannelSelector.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ChannelSelector.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.ChannelSelector.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ChannelSelector.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.ChunkBatchAligner">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">ChunkBatchAligner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ideal_chunksize</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ChunkBatchAligner" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer to rechunk an array along axis 0 so 1 chunk = M * batch_size</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_size</strong> (<em>int</em>) – the batch size</p></li>
<li><p><strong>ideal_chunksize</strong> (<em>int</em>) – a precalculated “ideal” chunk size based on RAM considerations, for
example this might be 60 with a batch_size of 7, which will result in
9 batches * 7 samples = 63 samples per chunk, the closest integer</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.ChunkBatchAligner.chk_cfg_">
<code class="sig-name descname">chk_cfg_</code><a class="headerlink" href="#gim_cv.preprocessing.ChunkBatchAligner.chk_cfg_" title="Permalink to this definition">¶</a></dt>
<dd><p>the chunk shape of the reshaped array</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.ChunkBatchAligner.batches_per_chunk_">
<code class="sig-name descname">batches_per_chunk_</code><a class="headerlink" href="#gim_cv.preprocessing.ChunkBatchAligner.batches_per_chunk_" title="Permalink to this definition">¶</a></dt>
<dd><p>the closest integer number of batches which will fit in a chunk of
ideal_chunksize</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.ChunkBatchAligner.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ChunkBatchAligner.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.ChunkBatchAligner.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ChunkBatchAligner.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.DimensionAdder">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">DimensionAdder</code><a class="headerlink" href="#gim_cv.preprocessing.DimensionAdder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Simple Transformer to add a channel dimension to an array if it’s 2D</p>
<p>For example, array with shape (H, W) -&gt; (H, W, 1)</p>
<dl class="py method">
<dt id="gim_cv.preprocessing.DimensionAdder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.DimensionAdder.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.DimensionAdder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.DimensionAdder.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.FancyPCA">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">FancyPCA</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">alpha_std</span><span class="o">=</span><span class="default_value">0.3</span></em>, <em class="sig-param"><span class="n">always_apply</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">max_samples</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.FancyPCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">albumentations.core.transforms_interface.ImageOnlyTransform</span></code></p>
<p>Augment RGB image using FancyPCA</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha_std</strong> (<em>float</em>) – Sampling gaussian perturbation stdev. See sample_channel_shift.</p></li>
<li><p><strong>always_apply</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to always apply.
See albumentations.core.transforms_interface.ImageOnlyTransform</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.FancyPCA.sampler">
<code class="sig-name descname">sampler</code><a class="headerlink" href="#gim_cv.preprocessing.FancyPCA.sampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Sampler instance used to derive channel shift vectors internally</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#gim_cv.preprocessing.PCAChannelShiftSampler" title="gim_cv.preprocessing.PCAChannelShiftSampler">PCAChannelShiftSampler</a></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>from Krizhevsky’s paper
“ImageNet Classification with Deep Convolutional Neural Networks”</p>
<p class="rubric">References</p>
<p><a class="reference external" href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf</a>
<a class="reference external" href="https://deshanadesai.github.io/notes/Fancy-PCA-with-Scikit-Image">https://deshanadesai.github.io/notes/Fancy-PCA-with-Scikit-Image</a>
<a class="reference external" href="https://pixelatedbrian.github.io/2018-04-29-fancy_pca/">https://pixelatedbrian.github.io/2018-04-29-fancy_pca/</a></p>
<dl class="py method">
<dt id="gim_cv.preprocessing.FancyPCA.alpha_std">
<em class="property">property </em><code class="sig-name descname">alpha_std</code><a class="headerlink" href="#gim_cv.preprocessing.FancyPCA.alpha_std" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.FancyPCA.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.FancyPCA.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.FancyPCA.get_params">
<code class="sig-name descname">get_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.FancyPCA.get_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.FancyPCA.get_transform_init_args_names">
<code class="sig-name descname">get_transform_init_args_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.FancyPCA.get_transform_init_args_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.Float32er">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">Float32er</code><a class="headerlink" href="#gim_cv.preprocessing.Float32er" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Simple Transformer wrapper for casting an array to 32-bit float</p>
<dl class="py method">
<dt id="gim_cv.preprocessing.Float32er.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Float32er.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.Float32er.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Float32er.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.ImageResampler">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">ImageResampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sf</span></em>, <em class="sig-param"><span class="n">preserve_int</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">resample_tolerance</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">is_mask</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">binary_mask_frac</span><span class="o">=</span><span class="default_value">0.1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ImageResampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer for applying skimage.rescale to an image-like dask array</p>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.ImageResampler.sf">
<code class="sig-name descname">sf</code><a class="headerlink" href="#gim_cv.preprocessing.ImageResampler.sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Resampling factor: 0.5 =&gt; half spatial resolution</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.ImageResampler.preserve_int">
<code class="sig-name descname">preserve_int</code><a class="headerlink" href="#gim_cv.preprocessing.ImageResampler.preserve_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that 8-bit integer inputs produce (rounded) 8-bit integer outputs</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.ImageResampler.resample_tolerance">
<code class="sig-name descname">resample_tolerance</code><a class="headerlink" href="#gim_cv.preprocessing.ImageResampler.resample_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>If sf is within resample_tolerance of 1.0, don’t resample.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.ImageResampler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ImageResampler.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.ImageResampler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.ImageResampler.transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em>) – Input Dask array (upon which fit was called)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Resampled dask image array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.OverlappingTiler">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">OverlappingTiler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">window_dims</span><span class="o">=</span><span class="default_value">(256, 256)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.OverlappingTiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Version of Tiler with half-window-size overlap.</p>
<p>Constructs four basic tilers: a normal tiler, one with half-step patch size
offset in the height and width dimensions individually, and one with both together.</p>
<p>Constructs arrays ~4x as large as a basic tiler as a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>window_dims</strong> – patch size to be constructed</p>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.preprocessing.OverlappingTiler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.OverlappingTiler.fit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em>) – Input (H, W, C) Dask array (upon which fit was called)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tiled (B, h, w, C) Dask array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.OverlappingTiler.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.OverlappingTiler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em>) – Tiled (B, h, w, C) Dask array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Input (H, W, C) Dask array (upon which fit was called)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.OverlappingTiler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.OverlappingTiler.transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em>) – Input (H, W, C) Dask array (upon which fit was called)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tiled (B, h, w, C) Dask array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.PCAChannelShiftSampler">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">PCAChannelShiftSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">alpha_std</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">max_samples</span><span class="o">=</span><span class="default_value">5000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.PCAChannelShiftSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Callable which generates shift vectors with “Fancy PCA” sampling for images</p>
<p>This derives the PCA decomposition of the channels from the input array, and
acts as a callable which generates random RGB shift vectors according to
this decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array_like</em>) – An image-like array with channels along the last axis. Used to calculate
shift vectors based on the eigendecomposition of the covariance matrix.</p></li>
<li><p><strong>alpha_std</strong> (<em>float</em><em>, </em><em>optional</em>) – The stdev of the gaussian used to sample the channel shifts according to
the eigendecompostion. wider =&gt; bigger perturbations.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.PCAChannelShiftSampler.eig_vals">
<code class="sig-name descname">eig_vals</code><a class="headerlink" href="#gim_cv.preprocessing.PCAChannelShiftSampler.eig_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>the channel covariance matrix’s eigenvalues in desc order of magnitude</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.PCAChannelShiftSampler.eig_vecs">
<code class="sig-name descname">eig_vecs</code><a class="headerlink" href="#gim_cv.preprocessing.PCAChannelShiftSampler.eig_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>the channel covariance matrix’s eigenvectors in the same order as evals</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an (n_channels,) shaped random shift vector</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.preprocessing.PCAChannelShiftSampler.calculate_eigenvectors">
<code class="sig-name descname">calculate_eigenvectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.PCAChannelShiftSampler.calculate_eigenvectors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.Rechunker">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">Rechunker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chunks</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">block_size_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Rechunker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer to adjust size of dask chunks between computations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chunks</strong> (<em>array_like</em><em> or </em><em>str</em><em> or </em><em>int</em><em>, </em><em>optional</em>) – see dask.array.Array.rechunk</p></li>
<li><p><strong>threshold</strong> – see dask.array.Array.rechunk</p></li>
<li><p><strong>optional</strong> – see dask.array.Array.rechunk</p></li>
<li><p><strong>block_size_limit</strong> (<em>array_like</em><em> or </em><em>int</em><em>, </em><em>optional</em>) – see dask.array.Array.rechunk</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.preprocessing.Rechunker.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Rechunker.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.Rechunker.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Rechunker.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.SimpleInputScaler">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">SimpleInputScaler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sf</span><span class="o">=</span><span class="default_value">0.00392156862745098</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SimpleInputScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Simple Transformer wrapper for scaling an array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sf</strong> (<em>float</em>) – scale factor, typically 1/255. to map 8-bit RGBs -&gt; [0, 1]</p>
</dd>
</dl>
<dl class="py method">
<dt id="gim_cv.preprocessing.SimpleInputScaler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SimpleInputScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.SimpleInputScaler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SimpleInputScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.SynchronisedShuffler">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">SynchronisedShuffler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">42</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SynchronisedShuffler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer to (un)shuffle array along axis 0 with a seeded permutation</p>
<p>Works with Dask or Numpy arrays.</p>
<p>Invertible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> (<em>int</em>) – random seed value</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.SynchronisedShuffler.random_index_permutation_">
<code class="sig-name descname">random_index_permutation_</code><a class="headerlink" href="#gim_cv.preprocessing.SynchronisedShuffler.random_index_permutation_" title="Permalink to this definition">¶</a></dt>
<dd><p>the permutation of indices specified by the random seed</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.SynchronisedShuffler.inverse_permutation_">
<code class="sig-name descname">inverse_permutation_</code><a class="headerlink" href="#gim_cv.preprocessing.SynchronisedShuffler.inverse_permutation_" title="Permalink to this definition">¶</a></dt>
<dd><p>the inverse permutation of indices to unshuffle the array</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.SynchronisedShuffler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SynchronisedShuffler.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.SynchronisedShuffler.get_arr_perm">
<code class="sig-name descname">get_arr_perm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">perm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SynchronisedShuffler.get_arr_perm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.SynchronisedShuffler.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SynchronisedShuffler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.SynchronisedShuffler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.SynchronisedShuffler.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.TileStacker">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">TileStacker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hypertile_shape</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(224, 224)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.TileStacker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer batching a (H, W, C) image array into (B, h, w, C); h, w &lt; H, W</p>
<p>Convert a 3D image array into 4D array of tiles with shape window_dims
(for use in e.g. ML inference) in the first two dimensions (w, h if channels
last).</p>
<p>This method works only where the input array neatly divides into tiles.
For a general version dealing with cases which don’t nearly divide see Tiler.</p>
<p>Invertible.</p>
<p>See:
<a class="reference external" href="https://stackoverflow.com/questions/42297115/">https://stackoverflow.com/questions/42297115/</a>
numpy-split-cube-into-cubes/42298440#42298440</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hypertile_shape</strong> (<em>array_like</em>) – (h, w); the dimensions of the small tiles making up the batches</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.TileStacker.X_hypertile_shape_">
<code class="sig-name descname">X_hypertile_shape_</code><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.X_hypertile_shape_" title="Permalink to this definition">¶</a></dt>
<dd><p>The full shape in 3D of each tile/patch</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.TileStacker.X_old_shape_">
<code class="sig-name descname">X_old_shape_</code><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.X_old_shape_" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of the original shape of the array</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.TileStacker.X_repeats_">
<code class="sig-name descname">X_repeats_</code><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.X_repeats_" title="Permalink to this definition">¶</a></dt>
<dd><p>Array with the ratios of the size to the tile size in each dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.TileStacker.X_order_">
<code class="sig-name descname">X_order_</code><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.X_order_" title="Permalink to this definition">¶</a></dt>
<dd><p>The order of the higher-dimensional X_tmpshape axis to transpose by
in the final step of the tiling operation</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.TileStacker.X_tmpshape_">
<code class="sig-name descname">X_tmpshape_</code><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.X_tmpshape_" title="Permalink to this definition">¶</a></dt>
<dd><p>An intermediary higher-dimensional shape to facilitate the tiling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">To Do</code></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">-----</code></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">Normalise the attribute names for parity with the other related tiling</code></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.TileStacker.methods">
<code class="sig-name descname">methods</code><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.methods" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#gim_cv.preprocessing.WindowFitter" title="gim_cv.preprocessing.WindowFitter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WindowFitter</span></code></a>, <a class="reference internal" href="#gim_cv.preprocessing.Tiler" title="gim_cv.preprocessing.Tiler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tiler</span></code></a></p>
</div>
<dl class="py method">
<dt id="gim_cv.preprocessing.TileStacker.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.TileStacker.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em>) – Tiled (B, h, w, C) array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Input (H, W, C) array (upon which fit was called)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.TileStacker.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.TileStacker.transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em><em> or </em><em>numpy.ndarray</em>) – Input (H, W, C) array (upon which fit was called)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tiled (B, h, w, C) array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array or numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.Tiler">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">Tiler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">window_dims</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Tiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer batching a (H, W, C) image array into (B, h, w, C); h, w &lt; H, W</p>
<p>Convert a 3D image array into 4D array of tiles with shape window_dims
(for use in e.g. ML inference) in the first two dimensions (w, h if channels
last).</p>
<p>repeating the necessary rows and columns back from the edge to form full
tiles.</p>
<p>Invertible.</p>
<p>As a consequence of using this in ML inference, parts of the edges/corners
will be slightly oversampled by some fraction of a window, ie the same edge
region may appear twice in two different training tiles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>window_dims</strong> (<em>array_like</em>) – (h, w); the dimensions of the small tiles making up the batches</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.Tiler.cropper_">
<code class="sig-name descname">cropper_</code><a class="headerlink" href="#gim_cv.preprocessing.Tiler.cropper_" title="Permalink to this definition">¶</a></dt>
<dd><p>WindowFitter transformer to crop evenly-dividing piece of the array</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#gim_cv.preprocessing.WindowFitter" title="gim_cv.preprocessing.WindowFitter">WindowFitter</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.Tiler.stacker_">
<code class="sig-name descname">stacker_</code><a class="headerlink" href="#gim_cv.preprocessing.Tiler.stacker_" title="Permalink to this definition">¶</a></dt>
<dd><p>TileStacker used to divide up the part of the array that fits neatly
into an integer numbe rof tilers</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#gim_cv.preprocessing.TileStacker" title="gim_cv.preprocessing.TileStacker">TileStacker</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.Tiler.extra_rows_">
<code class="sig-name descname">extra_rows_</code><a class="headerlink" href="#gim_cv.preprocessing.Tiler.extra_rows_" title="Permalink to this definition">¶</a></dt>
<dd><p>The excess rows at the end which don’t fully form a tile</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.Tiler.extra_cols_">
<code class="sig-name descname">extra_cols_</code><a class="headerlink" href="#gim_cv.preprocessing.Tiler.extra_cols_" title="Permalink to this definition">¶</a></dt>
<dd><p>The excess columns at the end which don’t fully form a tile</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Uses 3 stackers and croppers to tile the evenly-dividing piece of the array,
and the extra rows/columns respectively, plus a fourth object to address
the bottom right corner.</p>
<p>See fit method implementation for full details of the intermediate stages</p>
<dl class="py method">
<dt id="gim_cv.preprocessing.Tiler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Tiler.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.Tiler.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Tiler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em>) – Tiled (B, h, w, C) Dask array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Input (H, W, C) Dask array (upon which fit was called)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.Tiler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.Tiler.transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em>) – Input (H, W, C) Dask array (upon which fit was called)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tiled (B, h, w, C) Dask array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.preprocessing.WindowFitter">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">WindowFitter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">window_dims</span><span class="o">=</span><span class="default_value">(224, 224)</span></em>, <em class="sig-param"><span class="n">behaviour</span><span class="o">=</span><span class="default_value">'crop'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.WindowFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Transformer to crop an image-like array (along the first two axes)</p>
<p>The output is the subset of the input which fits into an integer multiple
of window_dims.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>window_dims</strong> (<em>array_like</em><em>, </em><em>optional</em>) – h, w of eventual window/tile size</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="gim_cv.preprocessing.WindowFitter.n_windows_r_">
<code class="sig-name descname">n_windows_r_</code><a class="headerlink" href="#gim_cv.preprocessing.WindowFitter.n_windows_r_" title="Permalink to this definition">¶</a></dt>
<dd><p>number of full window breadths along the rows</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">n_windows c_</code></dt>
<dd><p>number of full window breadths down the columns</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.WindowFitter.row_max_">
<code class="sig-name descname">row_max_</code><a class="headerlink" href="#gim_cv.preprocessing.WindowFitter.row_max_" title="Permalink to this definition">¶</a></dt>
<dd><p>max row index</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.preprocessing.WindowFitter.col_max_">
<code class="sig-name descname">col_max_</code><a class="headerlink" href="#gim_cv.preprocessing.WindowFitter.col_max_" title="Permalink to this definition">¶</a></dt>
<dd><p>max col index</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.WindowFitter.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.WindowFitter.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.preprocessing.WindowFitter.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.WindowFitter.transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>dask.array.Array</em><em> or </em><em>np.ndarray</em>) – Input (H, W, C) array (upon which fit was called)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Cropped (H’, W’, C) array; H’ &lt;= H, W’ &lt;= W</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array or np.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.apply_channel_shift">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">apply_channel_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">sampler</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#gim_cv.preprocessing.PCAChannelShiftSampler" title="gim_cv.preprocessing.PCAChannelShiftSampler">gim_cv.preprocessing.PCAChannelShiftSampler</a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.apply_channel_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a random channel shift vector and applies it to an image array</p>
<p>Uses ‘fancy PCA’ sampler and perturbs input image array in channel space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>array_like</em>) – input array with channels along the last dimension</p></li>
<li><p><strong>sampler</strong> (<a class="reference internal" href="#gim_cv.preprocessing.PCAChannelShiftSampler" title="gim_cv.preprocessing.PCAChannelShiftSampler"><em>PCAChannelShiftSampler</em></a>) – a sampler instance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>input image + sampled perturbation, applied globally to all pixels</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.balanced_oversample">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">balanced_oversample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image_arrays</span></em>, <em class="sig-param"><span class="n">mask_arrays</span></em>, <em class="sig-param"><span class="n">data_axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.balanced_oversample" title="Permalink to this definition">¶</a></dt>
<dd><p>Oversamples smaller image/mask arrays to match the largest number of samples present.</p>
<p>Calculates the largest number of samples present amongst the image arrays and mask
arrays given as input, then repeats elements from those with fewer samples until
each array has the same size and each dataset is equally represented.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_arrays</strong> (list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A list of image arrays, each element from a different dataset. Patches should be
distributed along axis 0 currently.</p></li>
<li><p><strong>mask_arrays</strong> (list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A list of mask arrays, each element from a different dataset. Patches should be
distributed along axis 0 currently. The ground truth for image_arrays.</p></li>
<li><p><strong>data_axis</strong> (<em>int</em><em>, </em><em>optional</em>) – The axis along which the samples are distributed. Currently only 0 implemented.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The input lists of arrays, with each element now having the same size.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple of list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">da.array.Array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.channel_cov_eigh">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">channel_cov_eigh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.channel_cov_eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the eigendecomposition of the channel data of an image array</p>
<p>Necessary step for the so-called “Fancy PCA” image augmentation technique</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array_like</em>) – A NumPy or Dask array with &gt;= 2 dimensions, the last corresponding to
the channels whose eigendecomposition will be calculated</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(eigenvalues, eigenvectors) sorted in decreasing order of eval magnitude</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.get_aug_datagen">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">get_aug_datagen</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rescale</span><span class="o">=</span><span class="default_value">0.00392156862745098</span></em>, <em class="sig-param"><span class="n">featurewise_center</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">featurewise_std_normalization</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">zca_whitening</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">horizontal_flip</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vertical_flip</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rotation_range</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">width_shift_range</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">height_shift_range</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">shear_range</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">zoom_range</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.get_aug_datagen" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory returning a data generator for image/mask augmentation.</p>
<p>Returns a tf.keras.preprocessing.image.ImageDataGenerator, which applies
transformations to numpy arrays during training.</p>
<p>Default just rescales RGB by 1/255.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rescale</strong> (<em>float</em><em>, </em><em>optional</em>) – Rescale factor for 8-bit integer RGBs to floats, typically 1/255.</p></li>
<li><p><strong>featurewise_center</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>featurewise_std_normalization</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>zca_whitening</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>horizontal_flip</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>vertical_flip</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>rotation_range</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>width_shift_range</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>height_shift_range</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
<li><p><strong>zoom_range</strong> (<em>bool</em><em>, </em><em>optional</em>) – See tf.keras.preprocessing.image.ImageDataGenerator</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An image data generator with the requested parameters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tf.keras.preprocessing.image.ImageDataGenerator</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.get_binary_mask_training_pipeline">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">get_binary_mask_training_pipeline</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">window_dims</span><span class="o">=</span><span class="default_value">(256, 256)</span></em>, <em class="sig-param"><span class="n">resample_factor</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">overlap_tiles</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">preserve_int</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">42</span></em>, <em class="sig-param"><span class="n">prepend_steps</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">resample_tolerance</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.get_binary_mask_training_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory returning a pipeline to preprocess binary mask rasters for training.</p>
<p>Applies operations for selecting, resampling, tiling and shuffling raw 2D
dask arrays extracted from rasters into a stack of patches ready for division
into batches and final-stage training augmentations. An explicit batching
is excluded to allow for doing this operation downstream together with the
appropriate images.</p>
<p>When used in conjunction with images representing training inputs, these
should be subjected to a subset of the same operations and shuffled by the
same random seed. For this there exists the sister-method with the same
arguments <cite>get_image_training_pipeline</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>window_dims</strong> (<em>array_like</em>) – The desired row, col size of patches used for training. Together with
the downstream batch_size, this is usually limited by GPU memory.
For example, (256,256) might permit O(10) images per batch.</p></li>
<li><p><strong>overlap_tiles</strong> (<em>bool</em>) – Toggles whether to use half-step overlapping patches rather than no-overlap.
Increases dataset size by factor of ~4</p></li>
<li><p><strong>resample_factor</strong> (<em>float</em>) – see ImageResampler</p></li>
<li><p><strong>preserve_int</strong> (<em>bool</em>) – see ImageResampler</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – Random seed for shuffling patches</p></li>
<li><p><strong>prepend_steps</strong> (<em>array_like</em>) – Any additional transformers which must be applied first. This
facilitates e.g. the insertion of dataset-specific channel preselections.</p></li>
<li><p><strong>resample_tolerance</strong> (<em>float</em>) – see ImageResampler</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pipeline encapsulating the preprocessing stages</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sklearn.pipeline.Pipeline</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.get_image_inference_pipeline">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">get_image_inference_pipeline</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inference_window_size</span><span class="o">=</span><span class="default_value">896</span></em>, <em class="sig-param"><span class="n">resample_factor</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">preserve_int</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">resample_tolerance</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">inference_batch_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">[0, 1, 2]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.get_image_inference_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory returning a pipeline to preprocess raster data for inference.</p>
<p>Applies operations for selecting, padding, resampling, tiling and
rescaling raw RGB dask arrays extracted from rasters into batches ready for
inference</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inference_window_size</strong> (<em>array_like</em>) – The desired row, col size of patches used for inference. Usually limited
by GPU memory (for example, (896,896))</p></li>
<li><p><strong>resample_factor</strong> (<em>float</em>) – see ImageResampler</p></li>
<li><p><strong>preserve_int</strong> (<em>bool</em>) – see ImageResampler</p></li>
<li><p><strong>resample_tolerance</strong> (<em>float</em>) – see ImageResampler</p></li>
<li><p><strong>inference_batch_size</strong> (<em>int</em>) – The number of patches per batch for inference. Defaults to 1, as this
allows the largest possible patch size thus mitigating edge-artifacts in
the output of inference.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pipeline encapsulating the preprocessing stages</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sklearn.pipeline.Pipeline</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.get_image_training_pipeline">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">get_image_training_pipeline</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">window_dims</span><span class="o">=</span><span class="default_value">(256, 256)</span></em>, <em class="sig-param"><span class="n">resample_factor</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">overlap_tiles</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">preserve_int</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">42</span></em>, <em class="sig-param"><span class="n">channels</span><span class="o">=</span><span class="default_value">[0, 1, 2]</span></em>, <em class="sig-param"><span class="n">prepend_steps</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">resample_tolerance</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.get_image_training_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory returning a pipeline to preprocess raster data for training.</p>
<p>Applies operations for selecting, resampling, tiling and shuffling raw RGB
dask arrays extracted from rasters into a stack of patches ready for division
into batches and final-stage training augmentations. An explicit batching
is excluded to allow for doing this operation downstream together with the
appropriate masks.</p>
<p>If the labelled training examples are also images, these should be
subjected to a subset of the same operations and shuffled by the same
random seed. For this there exist sister-methods covering common use cases
and with the same arguments, e.g. for binary semantic segmentation
<cite>get_binary_mask_training_pipeline</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>window_dims</strong> (<em>array_like</em>) – The desired row, col size of patches used for training. Together with
the downstream batch_size, this is usually limited by GPU memory.
For example, (256,256) might permit O(10) images per batch.</p></li>
<li><p><strong>resample_factor</strong> (<em>float</em>) – see ImageResampler</p></li>
<li><p><strong>overlap_tiles</strong> (<em>bool</em>) – Toggles whether to use half-step overlapping patches rather than no-overlap.
Increases dataset size by factor of ~4</p></li>
<li><p><strong>preserve_int</strong> (<em>bool</em>) – see ImageResampler</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – Random seed for shuffling patches</p></li>
<li><p><strong>prepend_steps</strong> (<em>array_like</em>) – Any additional transformers which must be applied first. This
facilitates e.g. the insertion of dataset-specific channel preselections.</p></li>
<li><p><strong>resample_tolerance</strong> (<em>float</em>) – see ImageResampler</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pipeline encapsulating the preprocessing stages</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sklearn.pipeline.Pipeline</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.get_partition_indices">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">get_partition_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">split_fracs</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(0.7, 0.15, 0.15)</span></em>, <em class="sig-param"><span class="n">divisible_by</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.get_partition_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates indices of the boundaries of an N-fold partition of an array</p>
<p>Used for splitting up e.g. train/test/validation sets</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – the length of an array along an axis which will be partitioned</p></li>
<li><p><strong>split_fracs</strong> (<em>array_like</em><em>, </em><em>optional</em>) – the fraction of elements in each partition, must sum to 1. e.g. (.5, .5)</p></li>
<li><p><strong>divisible_by</strong> (<em>int</em><em>, </em><em>optional</em>) – an integer into which partitions (up to the last) must divide</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of boundary indices of the partitions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.rescale_image_array">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">rescale_image_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span></em>, <em class="sig-param"><span class="n">sf</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">preserve_int</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.rescale_image_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies skimage.rescale to an image-like dask array by mapping over blocks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>array_like</em>) – Dask array with shape (rows, columns, channels)</p></li>
<li><p><strong>sf</strong> (<em>float</em>) – Resampling factor: 0.5 =&gt; half spatial resolution</p></li>
<li><p><strong>preserve_int</strong> (<em>bool</em>) – Ensure that 8-bit integer inputs produce (rounded) 8-bit integer outputs</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Resampled dask image array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dask.array.Array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.sample_channel_shift">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">sample_channel_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eig_vals</span></em>, <em class="sig-param"><span class="n">eig_vecs</span></em>, <em class="sig-param"><span class="n">alpha_std</span><span class="o">=</span><span class="default_value">0.1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.sample_channel_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a random channel shift vector to be added to each pixel of an image</p>
<p>Produces a linear combination of random variable alpha (sampled from normal
distn centred at 0 with std alpha_std) * cov eigenvalue * cov eigenvector</p>
<p class="rubric">Notes</p>
<p>Used in fancy PCA to apply data-derived channel shifts in RGB space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eig_vals</strong> (<em>array_like</em>) – eigenvalues of the channel covariance matrix sorted in decreasing order
of magnitude</p></li>
<li><p><strong>eig_vecs</strong> (<em>array_like</em>) – the channel-space eigenvectors to which of eig_vals applies</p></li>
<li><p><strong>alpha_std</strong> (<em>float</em>) – the stdev of the gaussian used to sample the eigenvalue magnitudes used
in generating the shift</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pert_vector</strong> – an (n_channels,) shaped array containing the channel-perturbation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.split_array">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">split_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">split_fracs</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(0.7, 0.15, 0.15)</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.split_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into N partitions each with a relative fraction of total size</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>array_like</em>) – Target array to be split into partitions</p></li>
<li><p><strong>split_fracs</strong> (<em>array_like</em>) – The fraction of elements in each partition</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – The axis along which the partitioning should occur</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sub-arrays with relative lengths of split_fracs of the total size of
the original</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.preprocessing.strong_aug">
<code class="sig-prename descclassname">gim_cv.preprocessing.</code><code class="sig-name descname">strong_aug</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">0.8</span></em>, <em class="sig-param"><span class="n">fancy_pca</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">p_rr90</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">p_hflip</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">p_rgb_shift</span><span class="o">=</span><span class="default_value">0.4</span></em>, <em class="sig-param"><span class="n">p_iaa_affine</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">p_noise</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">p_blur</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">p_ssr</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">p_distort</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">p_sharpen</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">p_contrast</span><span class="o">=</span><span class="default_value">0.4</span></em>, <em class="sig-param"><span class="n">p_brightness</span><span class="o">=</span><span class="default_value">0.3</span></em>, <em class="sig-param"><span class="n">p_hue_sat</span><span class="o">=</span><span class="default_value">0.05</span></em>, <em class="sig-param"><span class="n">p_gamma</span><span class="o">=</span><span class="default_value">0.1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.preprocessing.strong_aug" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a composition of albumentations image/mask transformations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>float</em><em>, </em><em>optional</em>) – Global augmentation probability in [0,1.] (of doing any augs at all)</p></li>
<li><p><strong>fancy_pca</strong> (<a class="reference internal" href="#gim_cv.preprocessing.FancyPCA" title="gim_cv.preprocessing.FancyPCA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FancyPCA</span></code></a>, optional) – An instance of FancyPCA, evaluated on the training dataset
with precalculated shift eigenvectors</p></li>
<li><p><strong>p_rr90</strong> – Probability of random rotation by multiple of 90 degrees</p></li>
<li><p><strong>p_hflip</strong> – Horizontal flip probability</p></li>
<li><p><strong>p_rgb_shift</strong> – Probability of random RGB shift</p></li>
<li><p><strong>p_iaa_affine</strong> – Probability of affine transformation</p></li>
<li><p><strong>p_noise</strong> – Probability of gaussian noise</p></li>
<li><p><strong>p_blur</strong> – Probability of gaussian blur</p></li>
<li><p><strong>p_ssr</strong> – Probability of shift-scale-rotate</p></li>
<li><p><strong>p_distort</strong> – Probability of distortion</p></li>
<li><p><strong>p_sharpen</strong> – Probability of sharpening</p></li>
<li><p><strong>p_contrast</strong> – Probability of contrast shift</p></li>
<li><p><strong>p_brightness</strong> – Probability of brightness shift</p></li>
<li><p><strong>p_hue_sat</strong> – Probability of hue-saturation shift</p></li>
<li><p><strong>p_gamma</strong> – Probability of gamma shift</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A composition of various albumentations transformations for
image augmentation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>albumentations.core.composition.Compose</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.training">
<span id="gim-cv-training-module"></span><h2>gim_cv.training module<a class="headerlink" href="#module-gim_cv.training" title="Permalink to this headline">¶</a></h2>
<p>training.py</p>
<p>Provides high-level training dataset classes which collect and apply
preprocessing operations to (sets of) rasters/images and provide batch
generators for training models.</p>
<p>Main APIs are the TrainingDataset and CompositeTrainingDataset classes.</p>
<dl class="py class">
<dt id="gim_cv.training.BaseTrainingDataset">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">BaseTrainingDataset</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Implements common methods for (Composite)TrainingDataset classes.
See these.</p>
<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.X">
<em class="property">abstract property </em><code class="sig-name descname">X</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.X_test">
<em class="property">property </em><code class="sig-name descname">X_test</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.X_test" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
As X_train, but for testing and with a different fractional size. If a
two-fold partitioning of train_val_test_split (e.g. (0.8, 0.2)) is used
for training and validation only, accessing this will return None.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.X_train">
<em class="property">property </em><code class="sig-name descname">X_train</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.X_train" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
A subset of the Dask array containing the input image arrays used for
training, with fractional size of the total data fixed by
train_val_test_split. Shaped as (batches, n_rows, n_cols, channels).</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.X_val">
<em class="property">property </em><code class="sig-name descname">X_val</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.X_val" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
As X_train, but for validation and with a different fractional size.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.batch_gen_test">
<code class="sig-name descname">batch_gen_test</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.batch_gen_test" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code> of array_like – Matching pairs of numpy arrays for each dask chunk for the testing
data as X, y pairs.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there is no testing fraction (i.e. train_val_test_split has only
    two values, interpreted as training and validation data only).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.batch_gen_train">
<code class="sig-name descname">batch_gen_train</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.batch_gen_train" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code> of array_like – Matching pairs of numpy arrays for each dask chunk for the training
data as X, y pairs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.batch_gen_val">
<code class="sig-name descname">batch_gen_val</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.batch_gen_val" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code> of array_like – Matching pairs of numpy arrays for each dask chunk for the validation
data as X, y pairs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.split_partition_block_indices">
<em class="property">property </em><code class="sig-name descname">split_partition_block_indices</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.split_partition_block_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
The indices of the blocks in the dask array containing the training
data which define the beginning of each section (train, val, test).
These respect the chunk structure of the underlying arrays, so that
each partitioning of the data is an integer number of dask chunks.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.split_partition_indices">
<em class="property">property </em><code class="sig-name descname">split_partition_indices</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.split_partition_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.tags">
<em class="property">property </em><code class="sig-name descname">tags</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.tags" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>:
The set of all unique tags associated with the training dataset(s).</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.train_val_test_split">
<em class="property">property </em><code class="sig-name descname">train_val_test_split</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.train_val_test_split" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
An sequence of floats summing to 1.0, specifying the fractions of the
data used to defined the training, validation and test sets</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.y">
<em class="property">abstract property </em><code class="sig-name descname">y</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.y_test">
<em class="property">property </em><code class="sig-name descname">y_test</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.y_test" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
As y_train, but for testing and with a different fractional size. If a
two-fold partitioning of train_val_test_split (e.g. (0.8, 0.2)) is used
for training and validation only, accessing this will return None.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.y_train">
<em class="property">property </em><code class="sig-name descname">y_train</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.y_train" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
A subset of the Dask array containing the output image arrays used for
training, with fractional size of the total data fixed by
train_val_test_split. Shaped as (batches, n_rows, n_cols, channels).
Typically a segmentation mask.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.BaseTrainingDataset.y_val">
<em class="property">property </em><code class="sig-name descname">y_val</code><a class="headerlink" href="#gim_cv.training.BaseTrainingDataset.y_val" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
As y_train, but for validation and with a different fractional size.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.training.CompositeTrainingDataset">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">CompositeTrainingDataset</code><span class="sig-paren">(</span><em class="sig-param">constituents=[]</em>, <em class="sig-param">batch_generator_fn=None</em>, <em class="sig-param">cache_directory=None</em>, <em class="sig-param">oversample_fn=None</em>, <em class="sig-param">prune_fn=&lt;function has_empty_raster&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gim_cv.training.BaseTrainingDataset" title="gim_cv.training.BaseTrainingDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">gim_cv.training.BaseTrainingDataset</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Interface for preparing diverse raster/image data for training.</p>
<p>Provides consolidated preprocessing, shuffling and batch generation for
training data spanning multiple rasters/images, each potentially subject to
its own independent preprocessing operations. Combines multiple independent
TrainingDatasets and adds (dask) shuffling and caching operations on the
composite arrays produced by mixing these.</p>
<p>Allows some flexibility in how batches are produced by setting the
batch_generator_fn attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>constituents</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <cite>TrainingDataset</cite>) – A list of the individual <cite>TrainingDataset</cite> objects constituting this
composite dataset, each of which interfaces to a raster file and mask.</p></li>
<li><p><strong>batch_generator_fn</strong> (<em>optional</em>) – Generator function with signature (X, y), where these are the training
inputs and masks respectively. Should return (x’, y’) numpy pairs for
each batch, each with shape (batch_size, H, W, C). Defaults to using the
same function used to generate batches as the first constituent
TrainingDataset.</p></li>
<li><p><strong>cache_directory</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code>, optional) – Path pointing to a directory where the processed X and y training arrays
can be dumped for re-use.</p></li>
<li><p><strong>oversample_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – A function with signature (image_arrays, mask_arrays), where each
is a list of arrays originating from different datasets. If this is
not None, it will be called early in the combination of different
TrainingDatasets to ensure equal representation of training examples
from each dataset. Should return a tuple the same form as its
signature: (image_arrays, masked_arrays), where these are assumed to
now be oversampled.</p></li>
<li><p><strong>prune_fn</strong> (<em>callable</em><em>, </em><em>optional</em>) – A callable which accepts a TrainingDataset, performs some calculation
and returns True if it’s to be removed from the constituents else False.
Used for eliminating rasters which are e.g. empty (all 255s).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Implements __add__ so that one can produce CompositeTrainingDatasets by
adding TrainingDatasets or CompositeTrainingDatasets to each other.</p>
<p>Some properties are copied from the first consituent TrainingDataset by
convention for the purposes of shuffling and rebatching, for example the
batch_size, seed and train_val_test_split.</p>
<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.X">
<em class="property">property </em><code class="sig-name descname">X</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.X" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the processed input image array.</p>
<p>The prepare method must previously have been run to access this.</p>
<dl class="simple">
<dt>array_like:</dt><dd><p>A consolidated (n_samples, H, W, C) input array for training</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.batch_generator_fn">
<em class="property">property </em><code class="sig-name descname">batch_generator_fn</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.batch_generator_fn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.batch_size">
<em class="property">property </em><code class="sig-name descname">batch_size</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.batch_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.cache_directory">
<em class="property">property </em><code class="sig-name descname">cache_directory</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.cache_directory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.composition_prepared">
<em class="property">property </em><code class="sig-name descname">composition_prepared</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.composition_prepared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.constituent_datasets_by_tag">
<code class="sig-name descname">constituent_datasets_by_tag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tag</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.constituent_datasets_by_tag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag</strong> (<em>str</em>) – A string tag associated with a given (set of) dataset(s)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of the constituent TrainingDataset objects with this tag</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of TrainingDataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.delete_prepared_arrays">
<code class="sig-name descname">delete_prepared_arrays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.delete_prepared_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes any cached zarr arrays generated from save_prepared_arrays</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.get_X">
<code class="sig-name descname">get_X</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.get_X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.get_y">
<code class="sig-name descname">get_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.get_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.load_prepared_arrays">
<code class="sig-name descname">load_prepared_arrays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.load_prepared_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads previously-calculated preprocessed and shuffled training arrays</p>
<p>The source directory is controlled by the cache_directory attribute.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.prepare">
<code class="sig-name descname">prepare</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">validate</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shuffle_repeats</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates preprocessed image/mask arrays ready for training</p>
<p>Applies preprocessing, concatenation, chunking, and shuffling operations
by applying the independent preprocessing operations of each constituent
TrainingDataset first, then assembling these individual arrays into
consolidated ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>validate</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag whether to apply array validation (slower)</p></li>
<li><p><strong>shuffle_repeats</strong> (<em>int</em><em>, </em><em>optional</em>) – Specifies the number of times to interleave slices of each block.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Due to dask working on blocks of arrays read lazily from multiple files,
“true” shuffling, which would mix patches from random areas of random
image files is somewhat tricky as this is very slow and memory intensive.
Here we use an approximation that interleaves elements from a fixed set
of random blocks from each source image from each batch. The degree to
which this kind of shuffling occurs is fixed by shuffle_repeats.</p>
<p>We see empirically that loss curves in training models smooth out after
a few iterations of shuffle_repeats and training converges.</p>
<p>This should probably be refactored so this function isn’t so monolithic,
perhaps into a compose_arrays method.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.prepared">
<em class="property">property </em><code class="sig-name descname">prepared</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.prepared" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag for marking when all preprocessing and batch assembly operations
have been applied. Gates other methods which require these steps to be
completed.</p>
<dl class="simple">
<dt>bool:</dt><dd><p>True if all consituents have been independently preprocessed and the
composition into shuffled batches has been completed. Basically if
the prepare method has been run.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.prune">
<code class="sig-name descname">prune</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls prune_fn (if set) on each constituent dataset and removes it from the
constituents list if this function returns True.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.save_prepared_arrays">
<code class="sig-name descname">save_prepared_arrays</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.save_prepared_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves preprocessed and shuffled training arrays to .zarr format</p>
<p>The target directory is controlled by the cache_directory attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>overwrite</strong> (<em>bool</em>) – Flag whether to overwrite existing arrays from the same dataset in
the same directory</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.seed">
<em class="property">property </em><code class="sig-name descname">seed</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.seed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.tags">
<em class="property">property </em><code class="sig-name descname">tags</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.tags" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>:
The set of all unique tags associated with the training dataset(s).</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.tags_str">
<em class="property">property </em><code class="sig-name descname">tags_str</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.tags_str" title="Permalink to this definition">¶</a></dt>
<dd><p>A string ID, formed by sorting and concatenating the unique
TrainingDataset tags</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.train_val_test_split">
<em class="property">property </em><code class="sig-name descname">train_val_test_split</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.train_val_test_split" title="Permalink to this definition">¶</a></dt>
<dd><p>array_like:
An sequence of floats summing to 1.0, specifying the fractions of the
data used to defined the training, validation and test sets</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.valid_constituents">
<em class="property">property </em><code class="sig-name descname">valid_constituents</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.valid_constituents" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag for marking whether all constituent TrainingDatasets are valid.</p>
<dl class="simple">
<dt>bool:</dt><dd><p>True if all constituents’ valid attributes are True else False</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.CompositeTrainingDataset.y">
<em class="property">property </em><code class="sig-name descname">y</code><a class="headerlink" href="#gim_cv.training.CompositeTrainingDataset.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the processed output mask array.</p>
<p>The prepare method must previously have been run to access this.</p>
<dl class="simple">
<dt>array_like:</dt><dd><p>A consolidated (n_samples, H, W, C) truth array for training</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="gim_cv.training.TrainingDataset">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">TrainingDataset</code><span class="sig-paren">(</span><em class="sig-param">image_src</em>, <em class="sig-param">mask_src</em>, <em class="sig-param">image_pipeline_factory</em>, <em class="sig-param">mask_pipeline_factory</em>, <em class="sig-param">batch_generator_fn</em>, <em class="sig-param">batch_size=None</em>, <em class="sig-param">image_validation_function=None</em>, <em class="sig-param">mask_validation_function=None</em>, <em class="sig-param">prune_patch_fn=&lt;function prune_all_black_or_white&gt;</em>, <em class="sig-param">seed=42</em>, <em class="sig-param">train_val_test_split=(0.6</em>, <em class="sig-param">0.2</em>, <em class="sig-param">0.2)</em>, <em class="sig-param">tag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.TrainingDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gim_cv.training.BaseTrainingDataset" title="gim_cv.training.BaseTrainingDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">gim_cv.training.BaseTrainingDataset</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Interface for preparing raster/image data from a file for training.</p>
<p>Provides consolidated preprocessing, shuffling and batch generation for
training data spanning multiple rasters/images, each potentially subject to
its own independent preprocessing operations. Combines multiple independent
TrainingDatasets and adds (dask) shuffling and caching operations on the
composite arrays produced by mixing these.</p>
<p>Allows some flexibility in how batches are produced by setting the
batch_generator_fn attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_src</strong> (str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code>) – Path to a raster/image file which will be moulded into input training
examples</p></li>
<li><p><strong>mask_src</strong> (str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">pathlib.Path</span></code>) – Path to a raster/image file which will be moulded into the corresponding
training ground truth labels to image_src</p></li>
<li><p><strong>image_pipeline_factory</strong> – A function which returns a <cite>sklearn.pipeline.Pipeline</cite> which performs
the preprocessing operations necessary to transform the raw image/raster
array from image_src into training-ready form.</p></li>
<li><p><strong>mask_pipeline_factory</strong> – A function which returns a <cite>sklearn.pipeline.Pipeline</cite> which performs
the preprocessing operations necessary to transform the raw image/raster
mask/ground truth array from mask_src into training-ready form.</p></li>
<li><p><strong>batch_generator_fn</strong> (<em>optional</em>) – Generator function with signature (X, y), where these are the training
inputs and masks respectively. Should return (x’, y’) numpy pairs for
each batch, each with shape (batch_size, H, W, C).</p></li>
<li><p><strong>batch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – The batch size to be used in training. This will be used to optimise the
dask chunk sizes.</p></li>
<li><p><strong>image_validation_function</strong> (<em>optional</em>) – An optional function to be applied to the raw input image/raster array
which returns True if it is considered valid. For example, a function
which returns True only if there are nonzero entries.</p></li>
<li><p><strong>mask_validation_function</strong> (<em>optional</em>) – An optional function to be applied to the raw ground truth mask array
which returns True if it is considered valid. For example, a function
which returns True only if there are nonzero entries.</p></li>
<li><p><strong>prune_patch_fn</strong> (<em>optional</em>) – An optional callable with signature fn(img_array, mask_array) that
retunrs pruned_img_array, pruned_mask_array</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – Random seed for shuffling</p></li>
<li><p><strong>train_val_test_split</strong> (<em>array_like</em>) – A sequence of floats summing to 1.0, specifying the fractional sizes of
the training, validation and testing datasets which the input images and
masks will be partitioned into.</p></li>
<li><p><strong>tag</strong> (<em>str</em><em>, </em><em>optional</em>) – A string identifier for this raster dataset. TrainingDatasets possessing
the same tag will be considered part of the same mother dataset and
bundled together for e.g. shuffling operations. Different rasters can
be grouped by similarity of content using this. Used downstream.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>&gt;&gt; from functools import partial
&gt;&gt; from gim_cv.preprocessing import (
&gt;&gt;    get_image_training_pipeline, get_binary_mask_training_pipeline,
&gt;&gt;    get_aug_datagen
&gt;&gt; )
&gt;&gt; from gim_cv.training import TrainingDataset, pair_batch_generator
&gt;&gt;
&gt;&gt;
&gt;&gt; # get function to generate batches of images and masks for each dataset,
&gt;&gt; # choosing a batch size and augmentation generator
&gt;&gt; batch_generator = partial(pair_batch_generator,
&gt;&gt;                           batch_size=batch_size,
&gt;&gt;                           img_aug=get_aug_datagen(),
&gt;&gt;                           mask_aug=get_aug_datagen(),
&gt;&gt;                           seed=seed,
&gt;&gt;                           shuffle=False)
&gt;&gt;
&gt;&gt; tds = TrainingDataset(
&gt;&gt;    ‘./training_data/image_1.tif’,
&gt;&gt;    ‘./training_data/mask_1.tif’,
&gt;&gt;    image_pipeline_factory=get_image_training_pipeline,
&gt;&gt;    mask_pipeline_factory=get_binary_mask_training_pipeline,
&gt;&gt;    batch_generator_fn=batch_generator,
&gt;&gt; )
&gt;&gt;
&gt;&gt; # build preprocessing operations
&gt;&gt; tds.prepare() # now arrays are generated as the X, y attributes
&gt;&gt;
&gt;&gt; model.fit_generator(tds.batch_gen_train(),
&gt;&gt;                     validation_data=training_data.batch_gen_val(),
&gt;&gt;                     …)</p>
<p class="rubric">Notes</p>
<p>Implements __add__ so that one can produce CompositeTrainingDatasets by
adding TrainingDatasets or CompositeTrainingDatasets to each other.</p>
<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.X">
<em class="property">property </em><code class="sig-name descname">X</code><a class="headerlink" href="#gim_cv.training.TrainingDataset.X" title="Permalink to this definition">¶</a></dt>
<dd><p>processed input image array</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.data_uid">
<em class="property">property </em><code class="sig-name descname">data_uid</code><a class="headerlink" href="#gim_cv.training.TrainingDataset.data_uid" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a stable id associated with this dataset’s input filenames.</p>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.get_X">
<code class="sig-name descname">get_X</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.TrainingDataset.get_X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.get_y">
<code class="sig-name descname">get_y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.TrainingDataset.get_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.load_arrays">
<code class="sig-name descname">load_arrays</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reload</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.TrainingDataset.load_arrays" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.make_pipelines">
<code class="sig-name descname">make_pipelines</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.TrainingDataset.make_pipelines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.prepare">
<code class="sig-name descname">prepare</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">optimise_chunks</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">validate</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.TrainingDataset.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to preprocess raw raster array data into training-ready state</p>
<p>Loads image/mask arrays (with cache-reliance behaviour deferred to config
via use_cache attr of readers), builds preprocessing pipelines then
applies their fit_transform method to the image/mask arrays to produce
training arrays with the shape (samples, H, W, C). Performs some batch/
chunk alignment optimisations and shuffling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>optimise_chunks</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to optimise dask chunks to span an integer multiple of batches</p></li>
<li><p><strong>validate</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to enforce array validation (via image_validation_function
and mask_validation_function methods) first.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Can skip pipeline step by explicitly setting pipeline = None</p>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.training.TrainingDataset.prepared">
<code class="sig-name descname">prepared</code><em class="property"> = False</em><a class="headerlink" href="#gim_cv.training.TrainingDataset.prepared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="gim_cv.training.TrainingDataset.tile_axis">
<code class="sig-name descname">tile_axis</code><em class="property"> = 0</em><a class="headerlink" href="#gim_cv.training.TrainingDataset.tile_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.validate_arrays">
<code class="sig-name descname">validate_arrays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.TrainingDataset.validate_arrays" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="gim_cv.training.TrainingDataset.y">
<em class="property">property </em><code class="sig-name descname">y</code><a class="headerlink" href="#gim_cv.training.TrainingDataset.y" title="Permalink to this definition">¶</a></dt>
<dd><p>processed output mask array</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.augment_all">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">augment_all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">augger</span></em>, <em class="sig-param"><span class="n">client</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.augment_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply image augmentations to a pair of arrays containing
images and masks with dimensions (N, H, W, C) and (N, H, W, C’)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A numpy image array of dimension (N, H, W, C)</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A numpy mask array of dimension (N, H, W, C’)</p></li>
<li><p><strong>augger</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">albumentations.Compose</span></code>) – An Albumentations transformer</p></li>
<li><p><strong>client</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">distributed.Client</span></code>) – A Dask Distributed client for submitting parallel augmentation jobs</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The augmented image and mask arrays</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">np.ndarray</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.ndarray</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.augment_image_and_mask">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">augment_image_and_mask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">augger</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.augment_image_and_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply augmentations to an image and mask together using an
Albumentations Transformer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>np.ndarray</em>) – Image with dimensions (H, W, C)</p></li>
<li><p><strong>mask</strong> (<em>np.ndarray</em>) – Mask with dimensions (H, W, C’)</p></li>
<li><p><strong>augger</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">albumentations.Compose</span></code>) – An Albumentations transformer</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>The augmented image and mask, stacked together for convenience</em></p></li>
<li><p><em>in a single array along the channel dimension</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.collate_run_data">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">collate_run_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">models_dir</span></em>, <em class="sig-param"><span class="n">model_name</span><span class="o">=</span><span class="default_value">'DeepResUNet'</span></em>, <em class="sig-param"><span class="n">dataset_aliases</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.collate_run_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dataframe containing metadata on all trained models in a directory</p>
<p>model_name can be a regex</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.fancy_batch_generator">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">fancy_batch_generator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span><span class="p">:</span> <span class="n">dask.array.core.Array</span></em>, <em class="sig-param"><span class="n">y</span><span class="p">:</span> <span class="n">dask.array.core.Array</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">augger</span></em>, <em class="sig-param"><span class="n">client</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">42</span></em>, <em class="sig-param"><span class="n">shuffle_blocks_every_epoch</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">shuffle_within_blocks</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">deep_supervision</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">float32</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.fancy_batch_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates batches of image/mask pairs from dask arrays with augmentations.</p>
<p>Proceeds chunk by chunk through the dask array, generating smaller numpy
arrays of the appropriate <cite>batch_size</cite> from these as it goes along. Applies
image and mask augmentations to each of these.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgs</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array of images distributed along axis 0</p></li>
<li><p><strong>masks</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array of masks distributed along axis 0</p></li>
<li><p><strong>batch_size</strong> (<em>int</em>) – The batch size of the yielded arrays</p></li>
<li><p><strong>augger</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">albumentations.Compose</span></code>) – An albumentations composed transformer class</p></li>
<li><p><strong>client</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">distributed.Client</span></code>, optional) – Dask distributed client for mapping parallel augmentation jobs</p></li>
<li><p><strong>deep_supervision</strong> (<em>bool</em><em>, </em><em>optional</em>) – Instead of returning masks, return a list of masks at
[8th, 4th, half, native] resolution. for attention pyramid unet.</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – Random seed</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em>) – Flags whether to shuffle within the chunks.</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> – (images, masks) with augmentations applied and shape (batch_size, h, w, c)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.from_first_constituent">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">from_first_constituent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.from_first_constituent" title="Permalink to this definition">¶</a></dt>
<dd><p>decorator to mirror properties from first constituent dataset</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.get_run_data">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">get_run_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model_dir</span></em>, <em class="sig-param"><span class="n">cp_ptn</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'cp-e(?P&lt;epoch&gt;\\d+)(-ji(?P&lt;ji&gt;[\\d.]+))?-l(?P&lt;loss&gt;[\\d.]+)-vl(?P&lt;val_loss&gt;[\\d.]+).ckpt.index'</span></em>, <em class="sig-param"><span class="n">dataset_aliases</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.get_run_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a model directory name, possibly containing checkpoints, to
reconstruct the loss function, training data used and best loss achieved</p>
<p>Assumes cp_ptn is a regex containing epoch, loss and val_loss match groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dataframe containing training metadata such as loss, dataset used, spatial
resolution and the paths to the best checkpoints</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pd.DataFrame</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.has_empty_raster">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">has_empty_raster</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tds</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#gim_cv.training.TrainingDataset" title="gim_cv.training.TrainingDataset">gim_cv.training.TrainingDataset</a></span></em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#gim_cv.training.has_empty_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if an training dataset image array is all 255s,
i.e. an empty raster. Loads the array interfaces in order to compute this.</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.pair_batch_generator">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">pair_batch_generator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imgs</span><span class="p">:</span> <span class="n">dask.array.core.Array</span></em>, <em class="sig-param"><span class="n">masks</span><span class="p">:</span> <span class="n">dask.array.core.Array</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">img_aug</span></em>, <em class="sig-param"><span class="n">mask_aug</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">42</span></em>, <em class="sig-param"><span class="n">shuffle_blocks_every_epoch</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">shuffle_within_blocks</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">float32</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.training.pair_batch_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates batches of image/mask pairs from dask arrays with augmentations.</p>
<p>Proceeds chunk by chunk through the dask array, generating smaller numpy
arrays of the appropriate <cite>batch_size</cite> from these as it goes along. Applies
image and mask augmentations to each of these.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgs</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array of images distributed along axis 0</p></li>
<li><p><strong>masks</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dask.array.Array</span></code>) – A dask array of masks distributed along axis 0</p></li>
<li><p><strong>batch_size</strong> (<em>int</em>) – The batch size of the yielded arrays</p></li>
<li><p><strong>img_aug</strong> – Generator implementing the interface of
<cite>tensorflow.keras.preprocessing.image.ImageDataGenerator</cite></p></li>
<li><p><strong>img_aug</strong> – Generator implementing the interface of
<cite>tensorflow.keras.preprocessing.image.ImageDataGenerator</cite></p></li>
<li><p><strong>seed</strong> (<em>int</em>) – Random seed</p></li>
<li><p><strong>shuffle</strong> (<em>bool</em>) – Flags whether to shuffle within the chunks.</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – The axis index along which the training samples are distributed.</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> – (images, masks) with augmentations applied and shape (batch_size, h, w, c)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.training.prune_all_black_or_white">
<code class="sig-prename descclassname">gim_cv.training.</code><code class="sig-name descname">prune_all_black_or_white</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span><span class="p">:</span> <span class="n">dask.array.core.Array</span></em>, <em class="sig-param"><span class="n">y</span><span class="p">:</span> <span class="n">dask.array.core.Array</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>dask.array.core.Array<span class="p">, </span>dask.array.core.Array<span class="p">]</span><a class="headerlink" href="#gim_cv.training.prune_all_black_or_white" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all black/white images and their corresponding masks</p>
<p>Returns the subset of the input image, mask arrays X, y with shapes
(patches, h, w, c) wherever X is “empty”, for example from masking
a non-rectangular shape over a raster and dividing it into patches</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">da.Array</span></code>) – Image patch array, shape (patches, h, w, channels)</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">da.Array</span></code>) – Mask patch array, shape (patches, h, w, mask_channels)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The pruned image/mask arrays</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">da.Array</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">da.Array</span></code></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-gim_cv.tuners">
<span id="gim-cv-tuners-module"></span><h2>gim_cv.tuners module<a class="headerlink" href="#module-gim_cv.tuners" title="Permalink to this headline">¶</a></h2>
<p>tuners.py</p>
<p>Provides custom kerastuner.Tuners for hyperparameter scans during model training.</p>
<dl class="py class">
<dt id="gim_cv.tuners.HyperbandOCP">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.tuners.</code><code class="sig-name descname">HyperbandOCP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hypermodel</span></em>, <em class="sig-param"><span class="n">objective</span></em>, <em class="sig-param"><span class="n">max_epochs</span></em>, <em class="sig-param"><span class="n">factor</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">hyperband_iterations</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hyperparameters</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tune_new_entries</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">allow_new_entries</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.tuners.HyperbandOCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">kerastuner.tuners.hyperband.Hyperband</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>Hyperband tuner with one-cycle policy learning-rate-adjusting callback</p>
<p>If the class has public attributes, they may be documented here
in an <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> section and follow the same formatting as a
function’s <code class="docutils literal notranslate"><span class="pre">Args</span></code> section. Alternatively, attributes may be documented
inline with the attribute’s declaration (see __init__ method below).</p>
<p>Properties created with the <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> decorator should be documented
in the property’s getter method.</p>
<dl class="py attribute">
<dt id="gim_cv.tuners.HyperbandOCP.attr1">
<code class="sig-name descname">attr1</code><a class="headerlink" href="#gim_cv.tuners.HyperbandOCP.attr1" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of <cite>attr1</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="gim_cv.tuners.HyperbandOCP.attr2">
<code class="sig-name descname">attr2</code><a class="headerlink" href="#gim_cv.tuners.HyperbandOCP.attr2" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of <cite>attr2</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="gim_cv.tuners.HyperbandOCP.run_trial">
<code class="sig-name descname">run_trial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trial</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">fit_args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">fit_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.tuners.HyperbandOCP.run_trial" title="Permalink to this definition">¶</a></dt>
<dd><p>Example function with PEP 484 type annotations.</p>
<p>The return type must be duplicated in the docstring to comply
with the NumPy docstring style.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trial</strong> (<em>int</em>) – The first parameter.</p></li>
<li><p><strong>*fit_args</strong> – The second parameter.</p></li>
<li><p><strong>**fit_kwargs</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if successful, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gim_cv.utils">
<span id="gim-cv-utils-module"></span><h2>gim_cv.utils module<a class="headerlink" href="#module-gim_cv.utils" title="Permalink to this headline">¶</a></h2>
<p>utils.py</p>
<p>Miscellaneous utility functions used elsewhere</p>
<dl class="py class">
<dt id="gim_cv.utils.RegisteredAttribute">
<em class="property">class </em><code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">RegisteredAttribute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">registry</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.RegisteredAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">timbermafia.Logged</span></code></p>
<p>descriptor</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.bounding_box_equals">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">bounding_box_equals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.bounding_box_equals" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/31400769/bounding-box-of-numpy-array">https://stackoverflow.com/questions/31400769/bounding-box-of-numpy-array</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>img</strong> (<em>2D numpy array</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple of slices for (row indices), (column indices) of box where arr == value</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.bounding_box_from_ixs">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">bounding_box_from_ixs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">ixs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.bounding_box_from_ixs" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/31400769/bounding-box-of-numpy-array">https://stackoverflow.com/questions/31400769/bounding-box-of-numpy-array</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>img</strong> (<em>2D numpy array</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple of slices for (row indices), (column indices) of box where arr == value</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.bounding_box_nonzero">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">bounding_box_nonzero</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.bounding_box_nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/31400769/bounding-box-of-numpy-array">https://stackoverflow.com/questions/31400769/bounding-box-of-numpy-array</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>img</strong> – 2D numpy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple of slices for (row indices), (column indices) of box where arr != 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.count_windows">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">count_windows</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">window_dims</span><span class="o">=</span><span class="default_value">(224, 224)</span></em>, <em class="sig-param"><span class="n">overlap</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#gim_cv.utils.count_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of windows in an image, given a window size and overlap</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – an array type data structure</p></li>
<li><p><strong>window_dims</strong> – the size of the desired patches</p></li>
<li><p><strong>overlap</strong> – the fraction that each window should overlap the next</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>integer no. of windows</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.cubify">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">cubify</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">new_shape</span><span class="p">:</span> <span class="n">tuple</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.cubify" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearrange large array into hypertiles, with these distributed
along a new dimension.</p>
<dl class="simple">
<dt>For example:</dt><dd><p>8 x 8 array w/ new_shape (2,2) -&gt; (16,2,2 array)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>np.array</em><em> or </em><em>dask.array.Array</em>) – </p></li>
<li><p><strong>new_shape</strong> (<em>a tuple</em><em>, </em><em>list</em><em> or </em><em>iterable specifying the</em>) – shape of the desired hypertiles.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An array of tiles with axis 0 being a new dimension</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">https</span></code></dt><dd><p>//stackoverflow.com/questions/42297115/</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy-split-cube-into-cubes</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.ensure_chunks_aligned">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">ensure_chunks_aligned</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arrs</span><span class="p">:</span> <span class="n">list</span></em>, <em class="sig-param"><span class="n">axis</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#gim_cv.utils.ensure_chunks_aligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of numpy or dask arrays, ensure that all of the
dask arrays are chunked along one target axis and have the
same dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arrs</strong> – a list of da.Array or np.ndarray objects</p></li>
<li><p><strong>axis</strong> – axis along which chunks must be distinguished</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A list of the arrays with the chunks reconfigured to match</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.free_from_white_pixels">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">free_from_white_pixels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.free_from_white_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if an array contains no RGB values (255, 255, 255)</p>
<p>Useful if (255, 255, 255) indicates missing data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>array</strong> – An image array with the last axis being the channel dimension</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>True if no white pixels, False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.hash_iterable">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">hash_iterable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterable</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.hash_iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a positive definite unique id for cached array file name</p>
<p>Hash tuple instead of XOR to prevent equal attr values on e.g. raster x/y size cancelling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iterable</strong> – Iterable of values to be hashed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Hex string of hashed values</p>
</dd>
</dl>
<p class="rubric">References</p>
<p><a class="reference external" href="https://stackoverflow.com/questions/18766535/positive-integer-from-python-hash-function">https://stackoverflow.com/questions/18766535/positive-integer-from-python-hash-function</a></p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.offset_by_strides">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">offset_by_strides</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">stride_size</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">n_strides</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#gim_cv.utils.offset_by_strides" title="Permalink to this definition">¶</a></dt>
<dd><p>From a base array, a stride_size and a number of strides
create a list of arrays formed by offsetting the original
by N * stride_size in each of the first two dimensions, where
N &lt;= n_strides</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – a np/dask array with at least 2 dimensions</p></li>
<li><p><strong>stride_size</strong> – an integer number of array indices per stride</p></li>
<li><p><strong>n_stride</strong> – the max number of strides</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A list of arrays formed by each of the offsets</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.onehot_initialization_v2">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">onehot_initialization_v2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.onehot_initialization_v2" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast solution for label-&gt;one-hot encoding, see:
<a class="reference external" href="https://stackoverflow.com/questions/36960320/convert-a-2d-matrix-to-a-3d-one-hot-matrix-numpy">https://stackoverflow.com/questions/36960320/convert-a-2d-matrix-to-a-3d-one-hot-matrix-numpy</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> – A numpy array of values representing label data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>One-hot encoded array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.onehot_sparse">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">onehot_sparse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.onehot_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast solution for label-&gt;one-hot encoding SPARSE - see:
<a class="reference external" href="https://stackoverflow.com/questions/36960320/convert-a-2d-matrix-to-a-3d-one-hot-matrix-numpy">https://stackoverflow.com/questions/36960320/convert-a-2d-matrix-to-a-3d-one-hot-matrix-numpy</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> – A numpy array of values representing label data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>One-hot encoded array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.parse_kwarg_str">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">parse_kwarg_str</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kwarg_str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.parse_kwarg_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses string from stdin into dict of kwargs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>kwarg_str</strong> (<em>str</em>) – String with comma-delineated kwarg pairs, like ‘x=1,y=2.5,z=chips’.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>{‘x’:1, ‘y’:2.5, ‘z’:’chips’} with numeric quantities type-guessed into int/floats</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.plot_img_and_mask">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">plot_img_and_mask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">overlay</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">figsize</span><span class="o">=</span><span class="default_value">(16, 8)</span></em>, <em class="sig-param"><span class="n">horizontal</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.plot_img_and_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a figure of an image and mask array side-by-side</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> – Array of shape (H, W, C)</p></li>
<li><p><strong>mask</strong> – Array of shape (H, W, C’)</p></li>
<li><p><strong>overlay</strong> – Toggles overlaying the mask on the image</p></li>
<li><p><strong>figsize</strong> – Passed to matplotlib subplots</p></li>
<li><p><strong>horizontal</strong> – If true, plot side-by-side rather than vertically arranged</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.plot_pair">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">plot_pair</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imgs</span></em>, <em class="sig-param"><span class="n">masks</span></em>, <em class="sig-param"><span class="n">ix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overlay</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">figsize</span><span class="o">=</span><span class="default_value">(16, 8)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.plot_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot an image/mask pair from a pair of arrays with shape (N, H, W, C(‘))</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgs</strong> – An array of shape (N, H, W, C) containing many image patches</p></li>
<li><p><strong>masks</strong> – An array of shape (N, H, W, C’) containing many mask patches</p></li>
<li><p><strong>ix</strong> – Index of patch to plot. Random if None.</p></li>
<li><p><strong>overlay</strong> – Flag to superimpose mask on image</p></li>
<li><p><strong>figsize</strong> – Passed to matplotlib subplots</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib pyplot figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.plot_sample_segmentation">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">plot_sample_segmentation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">images</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dask.array.core.Array<span class="p">, </span>numpy.array<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">masks</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">model</span><span class="p">:</span> <span class="n">tensorflow.python.keras.engine.training.Model</span></em>, <em class="sig-param"><span class="n">ix</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.plot_sample_segmentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to plot image/true/predicted segmentation masks
either randomly (default) or indexed</p>
<p>Delegates to plot_segmentation after deriving inputs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>images</strong> – a dask/numpy array containing RGB images</p></li>
<li><p><strong>masks</strong> – a dask/numpy binary array of ground truth masks</p></li>
<li><p><strong>model</strong> – a tf.keras model with a predict method</p></li>
<li><p><strong>ix</strong> – optional integer index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A matplotlib figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.plot_segmentation">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">plot_segmentation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">true_mask</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>numpy.array<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pred_mask</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>numpy.array<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>float<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overlay</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">figsize</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(30, 10)</span></em>, <em class="sig-param"><span class="n">return_plots</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#gim_cv.utils.plot_segmentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots an image and optionally also true and predicted segmentation masks,
with the further possibility of producing another binary segmentation map
by defining a float threshold</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> – a numpy array representing a base RGB image</p></li>
<li><p><strong>true/pred_mask</strong> – numpy arrays with the same dimensions as img, but 1 channel</p></li>
<li><p><strong>threshold</strong> – a float value to specify the binary decision threshold in pred_mask</p></li>
<li><p><strong>overlay</strong> – bool whether to superimpose the true mask on the iamge</p></li>
<li><p><strong>figsize</strong> – tuple fig size for matplotlib</p></li>
<li><p><strong>return_plots</strong> – bool whether to return fig and axes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>optionally fig and axes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.random_partitioned_index_permutation">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">random_partitioned_index_permutation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind1</span></em>, <em class="sig-param"><span class="n">ind2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">step</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">split_fracs</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(0.7, 0.15, 0.15)</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">42</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.random_partitioned_index_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array range in a given dimension, derive an N-fold
partitioning of indices spanning this range according to some
split fractions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ind1</strong> – the size of array if ind2 isn’t supplied, otherwise the starting index</p></li>
<li><p><strong>ind2</strong> – 1 + the largest index to appear</p></li>
<li><p><strong>step</strong> – the step in indices, like the third argument of range</p></li>
<li><p><strong>split_fracs</strong> – a tuple of floats specifying the fractional partition sizes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple of shuffled lists of indices, arranged according to split_fracs</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.require_attr_true">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">require_attr_true</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.require_attr_true" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to enforce an attribute is true when calling a method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>attr</strong> – String name of attribute which must be True</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.resize_array_to_fit_window">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">resize_array_to_fit_window</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">window_dims</span><span class="o">=</span><span class="default_value">(224, 224)</span></em>, <em class="sig-param"><span class="n">behaviour</span><span class="o">=</span><span class="default_value">'crop'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.resize_array_to_fit_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize a dask/np array to a size for which each dimension is
an integer multiple of window_dims</p>
<p>Currently assumes windows are extracted in first two dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – A numpy/dask array with first two dimensions (rows, cols)</p></li>
<li><p><strong>window_dims</strong> – pixel (H, W) of window</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.shuffle_and_split_array">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">shuffle_and_split_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">split_fracs</span><span class="o">=</span><span class="default_value">(0.7, 0.15, 0.15)</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">42</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.shuffle_and_split_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple composition of shuffle_array and split_array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – Dask/numpy array to shuffle and split</p></li>
<li><p><strong>split_fracs</strong> – The fractions of total length of the original array that each
of the resulting list of split arrays has</p></li>
<li><p><strong>seed</strong> – random seed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A list of shuffled arrays, partitioned into size determined by split_fracs</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.shuffle_array">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">shuffle_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span><span class="p">:</span> <span class="n">dask.array.core.Array</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">42</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.shuffle_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Seeded random permutation delegating to faster dask array shuffle method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – np/dask array</p></li>
<li><p><strong>seed</strong> – integer random seed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Shuffled array of type same as arr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.split_array">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">split_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">split_fracs</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(0.7, 0.15, 0.15)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.split_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array range in a given dimension, return an N-fold
partitioning according to some N split_fractions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – array</p></li>
<li><p><strong>split_fracs</strong> – tuple of floats - fraction of elements in each</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a list of arrays with relative lengths split_fracs</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.stride_overlap_and_resize">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">stride_overlap_and_resize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">window_dims</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(224, 224)</span></em>, <em class="sig-param"><span class="n">overlap</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">behaviour</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'crop'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.stride_overlap_and_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>From an array, generate a list of arrays formed by offsetting in both the row
and column dimensions by strides according to an overlap and window_dims
Resize each of the results to have rows/cols at an integer multiple of window_dims.</p>
<p>This is used to artificially increase the number of square windows which will
be the atomic units of training data by creating auxiliary, large arrays from
which these will be cut out, resulting in a set of overlapping windows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – a numpy/dask array with at least two dimensions</p></li>
<li><p><strong>window_dims</strong> – tuple of (n_rows, n_cols)</p></li>
<li><p><strong>overlap</strong> – float - the overlap fraction</p></li>
<li><p><strong>behaviour</strong> – method to resize the strided arrays (this is fed to resize_array_to_fit_window)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a list of resized arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.test_cubification">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">test_cubification</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.test_cubification" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the cubify and uncubify operations on dask arrays</p>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.uncubify">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">uncubify</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">old_shape</span><span class="p">:</span> <span class="n">tuple</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.uncubify" title="Permalink to this definition">¶</a></dt>
<dd><p>Untile an array, reducing its dimensionality by assembling
slices together in a grid in other dimensions.</p>
<p>The inverse of the cubify operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>np.array</em><em> or </em><em>dask.array.Array</em>) – </p></li>
<li><p><strong>old_shape</strong> (<em>a tuple</em><em>, </em><em>list</em><em> or </em><em>iterable specifying the</em>) – shape of the untiled array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An array with one fewer dimension with tiles stitched together</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">https</span></code></dt><dd><p>//stackoverflow.com/questions/42297115/</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy-split-cube-into-cubes</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.view_offsets">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">view_offsets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">window_dims</span><span class="p">:</span> <span class="n">tuple</span> <span class="o">=</span> <span class="default_value">(224, 224)</span></em>, <em class="sig-param"><span class="n">overlap</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">behaviour</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'crop'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.view_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualise result of offsetting array and tiling it</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – Numpy/dask image array (H, W, C)</p></li>
<li><p><strong>window_dims</strong> – Tile size</p></li>
<li><p><strong>overlap</strong> – overlap fraction between windows</p></li>
<li><p><strong>behaviour</strong> – crop</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.window_slices">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">window_slices</code><span class="sig-paren">(</span><em class="sig-param">arr</em>, <em class="sig-param">window_dims=(224</em>, <em class="sig-param">224)</em>, <em class="sig-param">overlap=0.5) -&gt; (&lt;class 'slice'&gt;</em>, <em class="sig-param">&lt;class 'slice'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.window_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator to yield slices with which to get patches from a large array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – an array type structure</p></li>
<li><p><strong>window_dims</strong> – the size of the desired windows</p></li>
<li><p><strong>overlap</strong> – the fraction that each patch should overlap the next</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>(x_slice, y_slice) for each patch in turn</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gim_cv.utils.yield_chunks">
<code class="sig-prename descclassname">gim_cv.utils.</code><code class="sig-name descname">yield_chunks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arrs</span></em>, <em class="sig-param"><span class="n">axis</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">loop</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#gim_cv.utils.yield_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Given some iterable of dask/np arrays, each with the same lengths along
the selected axis, yield numpy arrays for each of these by block
(for the dask arrays) or by the matching index ranges (for the np arrays)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arrs</strong> – a sequence of da.Array/np.ndarray objects which have the same shape</p></li>
<li><p><strong>axis</strong> – which axis is understood to align the different arrays for example,
along which are the different training examples</p></li>
<li><p><strong>loop</strong> – bool whether to continuously proceed</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>a tuple of numpy arrays, containing entries from each dask block</em></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-gim_cv">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-gim_cv" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="gim_cv.interfaces.html" class="btn btn-neutral float-right" title="gim_cv.interfaces package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="misc.html" class="btn btn-neutral float-left" title="Miscellaneous" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Nlemba Laurent.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>